newPackage(
        "Truncations",
        Version => "0.1", 
        Date => "12 Oct 2018",
        Authors => {
            {
                Name => "David Eisenbud", 
                Email => "de@msri.org", 
                HomePage => "http://www.msri.org/~de"},
            {
                Name => "Mike Stillman", 
                Email => "mike@math.cornell.edu", 
                HomePage=>"http://www.math.cornell.edu/~mike"}
            },
        Headline => "truncation of a module",
        DebuggingMode => true
        )

export {
    "trunc"
    }


trunc = method()
trunc(List,Module) := (D,M)->(
    --D can be a list of integers, of length = degreeLength ring M,
    --representing a single multi-degree, or a list of lists of multidegrees.
    --the function returns the submodule of M monomials of degree >=d for some d in D
    --requires that all the components of the degrees of R are all >=0.
    R := ring M;

    --in the easy case of a multiprojective space, don't bother with the aux ring.
    deglist := R_*/degree;
    if all(deglist, d->(sum d == 1 and all(d, i-> i>=0))) then return trunc0(D,M);

    --construct an embedding phi1 of R into a standard graded auxilliary ring:
    n := numgens R;
    dl := degreeLength R;
    --make a new ring T with n*dl variables, one for each (variable,degree component).
    kk := coefficientRing R;
    t := symbol t;
    T := kk[t_(0,0)..t_(n-1,dl-1)];
   --define a map R->T
    e:=0;
    targ := apply(numgens R, i -> (
	e = degree R_i;
	product(dl,j->t_(i,j)^(e_j))
	    ));
    phi1 := map(T,R,targ);

    --now construct the truncation, using the ring map over and over    
    if class D_0 =!= List then (
    L := gens M;
    dM := (degrees (gens M))_1;
    M1 := apply(#dM, i-> 
	    trunc(positivePart(D-dM_i),phi1)*image(L_{i}));
    trim sum M1) else
    trim sum(D, d->trunc(d,M))
    )

positivePart = method()
positivePart List := L -> apply(L, ell-> max(ell,0))

trunc0 = method()
trunc0(List, Module) := (D,M) ->(
    --A fix for the basic truncate command in the case of a module on multi-projective space.
    --If i is a multi-degree, then the result of truncate(i,M)
    --should be the submodule generated by all elements of degree >= i in the partial order.
    --The script assumes that the degrees of the variables in ring M are the basis vectors,
    --not something more exotic.
    if class D_0 =!= List then (
    dl := degreeLength M;
    L := gens M;
    dM := (degrees (gens M))_1;
    if all(dM, m -> all(dl, i-> m_i<=D_i)) then return image basis(D,M);
    S := ring M;
    M1 := apply(#dM, i-> 
	    ideal(basis(positivePart(D-dM_i),S,Truncate=>true))*image (L_{i}));
    sum M1) else
    trim sum(D, d->trunc0(d,M))
    )

trunc(List,RingMap) := (d,phi) ->(
    --for the moment we need T to be of the special form greated in trunc(List, Ring):
    --namely, variable t_(i,j) etc.
    --note that t_(i,j) = T_(i+n*j).
    R := source phi;
    n := numgens R;
    dl := degreeLength R;
    T := target phi;
    --should have n*dl variables t_(i,j), 0<=i<=n-1, and 0<=j<=dl-1 -- that is,
    -- one for each pair (variable, degree component).
    --now find the ideal in T of elements of degree >= d.
--    Td := product(dl,j->(ideal(apply(n,i->t_(i,j))))^(d_j));
      Td := product(dl,j->(ideal(apply(n,i->T_(i+n*j))))^(d_j));
    --the desired ideal is a kernel
    ker(map(T/Td,T)*phi)
    )

trunc(List, Ring) := (d,R) ->(
    --produce the ideal in R of all monomials of degree >=D
    --requires that all the components of the degrees of R are all >=0.
    n := numgens R;
    dl := degreeLength R;
    --make a new ring T with n*dl variables, one for each (variable,degree component).
    kk := coefficientRing R;
    t := symbol t;
    skewvarsT := if not R.?SkewCommutative then {} 
                 else (
                    skewvarsR := R.SkewCommutative;
                    flatten for i in skewvarsR list for j from 0 to dl-1 list t_(i,j)
                    );
    T := kk[t_(0,0)..t_(n-1,dl-1), SkewCommutative=>skewvarsT];
      
   --now find the ideal Td in T of elements of degree >= d.
    Td := product(dl,j->(ideal(apply(n,i->t_(i,j))))^(d_j));
   --define a map R->T
    e:=0;
    targ := apply(numgens R, i -> (
	e = degree R_i;
	product(dl,j->t_(i,j)^(e_j))
	    ));
    phi1 := map(T,R,targ);
       --the desired ideal is a kernel of the composite map R --> T/Td.
    U := T ** R;
    Utarg := ideal apply(numgens R, i -> (
	e = degree R_i;
	sub(R_i,U) - sub(product(dl,j->t_(i,j)^(e_j)),U)
        ));
    J := Utarg + sub(Td, U);
    return trim ideal sub(selectInSubring(1, gens gb J), R);
    psi := map(T/Td,T)*phi1;
    psi
    --ker psi
    )

TEST ///
  S = ZZ/101[a,b, Degrees =>{{0,1},{1,0}}]
  M = S^{-{5,2}, -{2,3}}
  D = {4,3}
  E = {{4,3},{3,4}}
  assert(trunc(D,S) == ideal(a^3*b^4))
  assert(trunc(D,S^1) == image matrix {{a^3*b^4}})
  assert(trunc(E,S^1) == image matrix {{a^3*b^4, a^4*b^3}})
  assert(trunc(E,M) == image(map(S^{{-5, -2}, {-2, -3}},, {{0, 0, a}, {b^2, a*b, 0}})))
-*
  trunc0(D,S^1)
  trunc0(D,M)
  trunc(D,M)
  trunc0(E,M)
*-
///

TEST ///
  kk = ZZ/101
  R = kk[a,b,c,Degrees =>{2:{3,4},{7,5}}]
  d = {5,6}
  D = {d,reverse d}

  elapsedTime J = trunc(d,R)
  M = R^1
  J = trunc(d,R^1)
  J_*/degree
  K = trunc(D,R^1)
///

beginDocumentation()
end--

doc ///
Key
  Truncation
Headline
Description
  Text
  Example
Caveat
SeeAlso
///

doc ///
Key
Headline
Usage
Inputs
Outputs
Consequences
Description
  Text
  Example
  Code
  Pre
Caveat
SeeAlso
///

TEST ///
-- test code and assertions here
-- may have as many TEST sections as needed
///

end--
restart
loadPackage "Truncations"
