newPackage(
        "FGLM",
        Version => "1.0.0",
        Date => "January 29, 2019",
        Authors => {
	    { Name => "Dylan Peifer", Email => "djp282@cornell.edu", HomePage => "https://www.math.cornell.edu/~djp282" },
	    { Name => "Mahrud Sayrafi", Email => "mahrud@umn.edu", HomePage => "https://math.umn.edu/~mahrud" }
	    },
        Headline => "Compute Groebner bases via the FGLM algorithm",
        DebuggingMode => true
        )

-*
Copyright (C) 2019 Dylan Peifer and Mahrud Sayrafi

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*-

export {"fglm"}

-------------------------------------------------------------------------------
--- top level functions
-------------------------------------------------------------------------------

---------------------------------------------------------------------------
-- See Section 2.4.4 of Thibaut Verron's thesis for details:
-- https://thibautverron.github.io/doc/2016-these.pdf
---------------------------------------------------------------------------
fglm = method()
fglm(Ideal,         Ring) := GroebnerBasis => (I1, R2) -> fglm(gb I1, R2)
fglm(GroebnerBasis, Ring) := GroebnerBasis => (G1, R2) -> (
    -- G1 = a Groebner basis for I1 in R1
    -- R2 = a polynomial ring
    -- returns Groebner basis G2 of the ideal generated by G1 in the ring R2

    R1 := ring G1;
    I1 := ideal gens G1; -- TODO: find a way to avoid recomputing GB
    if R1 == I1 then return forceGB(sub(gens G1, R2));
    if dim I1 > 0 then error "expected zero-dimensional ideal";
    if #gens R1 != #gens R2 then error "expected the same number of generators";

    M := multiplicationMatrices G1;
    m := numcols M#0;
    n := #gens R2;

    -- elements in the grobner basis
    G2 := {};
    -- elements in the staircase
    B2 := {1_R2};

    -- normal form translation table
    V := new MutableHashTable from {
	 B2#0 => transpose matrix { {1_(coefficientRing R1)} | toList ((m-1):0) } 
	 };

    -- list of elements between the staircase and grobner basis generators
    -- TODO: use a heap
    S := new MutableHashTable from for i to n - 1 list R2_i * 1_R2 => (i, 1_R2);

    while #S > 0 do (
	(elt, vals) := min pairs S;
	(i, mu) := vals;
	v := M#i * V#mu;

	VS := matrix { for s in B2 list V#s };
	if v % VS == 0 then (
--	if rank(VS | v) == numcols VS then ( -- not much faster
	    lambda := solve(VS, v);
--	    lambda := syz(VS | v, SyzygyRows => numcols VS); -- FIXME: why does this fail?
	    g := elt - matrix {B2} * lambda;
	    G2 = append(G2, g);
	    apply(pairs S, (k, v) -> if k % elt == 0 then remove(S, k));
	    ) else (
	    V#elt = v;
	    B2 = append(B2, elt);
	    for j to n - 1 do S#(R2_j * elt) = (j, elt);
	    apply(B2, b -> remove(S, b));
	    );
	);
    forceGB(matrix {G2})
    )

multiplicationMatrices = method()
multiplicationMatrices(GroebnerBasis) := List => (G) -> (
    -- G = a GroebnerBasis
    -- returns the matrices giving multiplication by variables in R/I

    R := ring G;
    I := ideal gens G;
    B := basis (R/I); -- TODO: find a way to avoid recomputing GB

    mons := first entries B;
    mats := {};

    for x in gens R do (
	F := first entries (x * B);
	M := transpose matrix for f in F list for m in mons list f_m;
	mats = append(mats, M);
    );

    mats
    )

-------------------------------------------------------------------------------
--- documentation
-------------------------------------------------------------------------------
beginDocumentation()

-------------------------------------------------------------------------------
--- tests
-------------------------------------------------------------------------------
test = (I1, MO2) -> (
    R1 := ring I1;
    R2 := (coefficientRing R1)(monoid ([gens R1], MonomialOrder => MO2));
    elapsedTime G2 := gb(sub(I1, R2));
    elapsedTime G2' := fglm(I1, R2);
    assert(gens G2 == gens G2')
    )

TEST ///
  debug needsPackage "FGLM"
  R1 = QQ[x,y,z]
  I1 = ideal(x*y + z - x*z, x^2 - z, 2*x^3 - x^2*y*z - 1)
  test(I1, Lex)
///

TEST ///
  debug needsPackage "FGLM"
  R1 = QQ[x,y,z]
  I1 = ideal(x^2 + 2*y^2 - y - 2*z, x^2 - 8*y^2 + 10*z - 1, x^2 - 7*y*z)
  test(I1, Lex)
///

TEST ///
  debug needsPackage "FGLM"
  R1 = QQ[x,y,z]
  I1 = ideal(x^2 + y^2 + z^2 - 2*x, x^3 - y*z - x, x - y + 2*z)
  test(I1, Lex)
///

TEST ///
  debug needsPackage "FGLM"
  R1 = QQ[x,y,z]
  I1 = ideal(x*y + z - x*z, x^2 - z, 2*x^3 - x^2*y*z - 1)
  test(I1, Lex)
///

TEST ///
  
///

end

restart
needsPackage "FGLM"
elapsedTime check FGLM -- ~2.7 seconds

restart
uninstallPackage "FGLM"
restart
installPackage "FGLM"
viewHelp "FGLM"
