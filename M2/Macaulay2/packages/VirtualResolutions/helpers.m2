-- Helper function for multigradedRegularity
-- borrowed from LinearTruncations:
multigradedPolynomialRing = n -> (
    x := local x;
    xx := flatten apply(#n, i -> apply(n_i+1, j -> x_(i,j)));
    degs := flatten apply(#n, i -> apply(n_i+1, k ->
            apply(#n, j -> if i == j then 1 else 0)));
    ZZ/32003[xx, Degrees=>degs]
    )
LL = method()
LL(ZZ,ZZ) := (d,t) -> (
    --produces the exponent list of the d-th power of the max ideal in n vars
    if t==1 then {{d}} else if d==0 then {toList(t:0)} else
    flatten apply(d+1, i ->
	apply(LL(d-i, t-1), ell -> flatten prepend(i,ell))
	)
    )
protect Inner
protect Outer
findRegion = method(Options => true)
findRegion(List,Ideal, Function) :=
findRegion(List,Module,Function) := true >> opts -> (range,M,f0) -> (
    t := degreeLength ring M;
    (low, high) := toSequence range;
    T := ZZ/2[vars(0..t-1)];
    f := if options f0 === null then f0 else (
	fopts := select(keys options f0, k -> opts#?k);
	fopts  = fopts / (k -> k => opts#k);
	(ell, M) -> f0(ell, M, new OptionTable from fopts)
	);
    L0 := if opts.?Inner then opts.Inner else {};
    I  := ideal({0_T} | apply(L0, ell -> T_(ell - low)));
    --assume I0 to be in I without checking
    K0 := if opts.?Outer then opts.Outer else {low};
    --don't check outside of region generated by K0
    ht := new MutableHashTable from apply(K0,
	ell -> T_(ell - low) => ell);
    while #ht > 0 do (
	(elt, ell) := min pairs ht;
	remove(ht, elt);
	if elt % I == 0 then continue;
	if f(ell, M) then I = I + ideal elt else (
	    scan(T_*, g -> (
		    leaf := first exponents(g * elt) + low;
		    if all(high - leaf, i -> i >= 0)
		    and not ht#?(g * elt)
		    then ht#(g * elt) = leaf
		    ))
	    )
	);
    (findMins I)/(ell -> ell + low)
    )
findMins = method()
findMins Ideal := I -> (
    apply(flatten entries mingens I, m -> flatten exponents m)
    )

gradedPolynomialRing = n -> (
    y := local y;
    yy := flatten apply(#n, i -> apply(n_i+1, j -> y_(i,j)));
    ZZ/32003[yy])

plotRegion = method()
plotRegion(Function, List, List) := (func, low, high) -> printerr netList(Boxes => false,
    table(min(high - low) + 1, max(high - low) + 1,
	(i, j) -> if func(j + first low, first high - i) then "." else "x"))
plotRegion(List, List, List) := (L, low, high) -> plotRegion(
    (i, j) -> any(L, ell -> i >= ell_0 and j >= ell_1), low, high)


-- input: the NormalToricVariety of a product of projective spaces or its Cox ring
-- output: the dimension vector for the product of projective spaces.
-- Note the dimension is ordered assuming the degree {1,0,...} is first.
dimVector = method()
dimVector NormalToricVariety := X -> dimVector entries transpose fromWDivToCl X
dimVector Ring := S -> dimVector degrees S
dimVector List := deg -> (
    degTally := tally deg; apply(rsort unique deg, i -> degTally_i - 1))

-- data for translating between NormalToricVarieties and TateOnProducts
importFrom_TateOnProducts { "BeilinsonBundles", "CohomRing", "TateData", "TateRingData", "ringData" }

-- input: NormalToricVariety (without the Cox ring cached)
-- output: NormalToricVariety, whose cached Cox ring has Tate Data
normalToricVarietyWithTateData = X -> (
    -- TODO: also check that X is a product of toricProjectiveSpaces
    S := ring X;
    if S.?TateData then X else (
	-- borrowed from productOfProjectiveSpaces in TateOnProducts.m2:288
	e := getSymbol "e";
	h := getSymbol "h";
	k := getSymbol "k";
	kk := coefficientRing S;
	degs := degrees S;
	E := kk[e_0..e_(#degs-1), Degrees => degs, SkewCommutative => true];
	CR := ZZ[h,k];
	tateData := new MutableHashTable;
	tateData#Rings = (S,E);
	tateData#CohomRing = CR;
	tateData#BeilinsonBundles = new MutableHashTable;
	S.TateData = tateData;
	E.TateData = tateData;
	X))

-- input: multigraded polynomial ring with Tate Data
-- output: NormalToricVariety, with the given ring cached in it
normalToricVarietyFromTateData = S -> (
    if S.?variety and S.?variety.?ring and S.?variety.cache.ring.?TateData then return S.variety;
    if not S.?TateData then error "expected a ring with TateData";
    X := tensor apply(dimVector S, n -> toricProjectiveSpace(n, CoefficientRing => coefficientRing S));
    X.cache.ring = S; S.variety = X)

-- input: multigraded polynomial ring without Tate Data
-- output: a new multigraded polynomial ring with Tate Data (the generators will be different!)
-- TODO: change this to support arbitrary variable names
imbueRingWithTateData = S0 -> (
    if S0.?TateData then return S0;
    (S, E) := productOfProjectiveSpaces(dimVector S0, CoefficientField => coefficientRing S0);
    S.variety = normalToricVarietyFromTateData S; S)
