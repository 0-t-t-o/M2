Todo for branch res-2018, created 9 March 2018.

1. Allow FastNonminimal resolutions to assume we have the GB.

2. Allow these to work with multi-gradings, as well as inhomogenoeus.

3. stash the nonminimal res, in a different location. What functions actually use nonminimal resolutions.

4. allow QQ as an actual coefficient ring.  Actually, allow any
  coefficient ring, as long as we are given a monic Groebner basis for
  it.
  
5. modules are not working correctly: there is a mismatch of monomial orders.  How best to fix this?

6. nonminimal --> minimal resolution.  How best to do this?  e.g. use zig-zag idea of Frank?

7. fix NonminimalComplexes package.

8. schreyerName functionality, in the engine?

Strategy 4 or 5 or 4.1
  Do NOT require that the module be graded.
  Place somewhere else:
    M.cache.RawNonminimalResComputation
  and then in the chain complex, place it somewhere?  I think not! Or, maybe, we do.
  
Strategy=>5:
  assume that the input is a cokernel module of a matrix whose columns form a GB.
    i.e. don't compute the GB.
  
  
to get working with arbitrary multi-gradings:
  res-f4-m2-interface.cpp:
    1. Determine what minimalBetti should do (well, in presence of DegreeLimit...)
    2. setDegreeZeroMap: needs to take a multi-degree
    3. rank: need to determine all the (multi)degrees one needs to do.
    4. to_M2_freemodule: need to keep somehow all of these modules.
     one easy way: the frame could keep the multi-degree.  This would help with all of these points.
  what about in the algorithm itself? It seems that other than placing the multi-degree in, nothing else is needed.
    creation of the frame?
    knowing what level,degree to do next?
    doing that one
  minimal_betti (res-f4-computation.cpp): calls minimalBettiNumbers    
What about inhomogeneous input?
  minimalBetti: no longer valid, should give an error.
  degreeZeroMap: gives an error?
  rank: same
  what else gives an error?
  
to_M2_MutableMatrix: the ring K needs to be checked!!!

maybe: another function for minimalBettiNumber, for a specific degree?
  It would reuse computation so it doesn't do extra work?
  what does "computeRank" do?  what is the 'status' bit...
    fillInSyzygies: need a function about what degrees are less than a given one:
      i.e. difference is the degree of a monomial in the ring.
      this might be computationally a pain, so another option: just do all up to heft-1 first.
      what is best here?
mComputationStatus: might need a hash table?
The frame should keep a hash table of the multi-degrees
  then mComputationStatus will have keys: (level,multi-degree).      
  

pseudo-code:

start_computation: (this is for determining the actual maps in a nonminimal res)
  computeFrame()
  computeSyzygies(sldeg,lev)

minimalBettiNumbers:
  computeFrame()
  for some(sldeg,lev) do computeRank(sldeg,lev) (this also changes betti display)

computeFrame():
  call computeNextLevel() for each level in turn
  set state of the computation
  
computeNextLevel():
  add in all ideal quotient elements at this level.
  set schreyer order for this level.
  
setSchreyerOrder(lev):
    schreyerOrder(lev-1) -- should alreday be set?
    schreyerOrder(lev).mTieBreaker -- this one is set by this routine
    schreyerOrder(lev).mTotalMonom -- is set earlier: in insertBasic.

computeSyzygies(sldeg,lev):

res-moninfo-dense:
  format [hashval, comp, w1, w2, ..., wr, e1, ..., en]
  notice: hash value does NOT involve the component.
  Change to allow weight vector(s)
  do we really need the hash values in the monomials?  Not sure...
  write several versions of compare_schreyer: one which includes revlex, and weight vectors.
  