doc ///
Node
  Key
    Truncations
  Headline
    truncations of graded ring, ideals and modules
  Description
    Text
      This package provides for the truncation of a graded ring, or a graded
      module or ideal over a graded ring.  Truncation is functorial: it can be applied
      to matrices as well, and the truncation of a composition of maps is the composition
      of the truncations.

      If $R$ is a $\ZZ^r$-graded ring, and $M$ is a graded module, and $D$ is a (finite)
      set of degrees in $\ZZ^r$, then the truncation {\tt truncate(D, M)} is
      $$M_{\ge D} = \oplus_{m} M_m,$$
      where the sum is over all $m \in \ZZ^r$, which are
      component-wise greater than at least one element $d \in D$.

      This definition makes the truncation into a submodule in the case when all degrees
      are non-negative.  In the case when some degree components are negative, this
      is likely not a submodule.

      This package handles the multi-graded case correctly, at least for the case
      of non-negative degree vectors for the variables, and the
      @TO "truncate"@ function is functorial (see @TO (truncate, List, Matrix)@).
  Caveat
    The behavior of @TO "truncate"@ has changed as of Macaulay2
    version 1.13.  This is a (potentially) breaking change.  Before,
    it used a less useful notion of truncation, involving the heft
    vector, and was often not what one wanted in the multi-graded
    case.  Additionally, in the tower ring case, when the coefficient
    ring had variables of nonzero degree, sometimes incorrect answers
    resulted.
  SeeAlso
    (truncate,List,Matrix)
    (truncate,List,Module)
    basis

Node
  Key
    (truncate,ZZ,Module)
    (truncate,List,Module)
    (truncate,ZZ,Ideal)
    (truncate,List,Ideal)
    (truncate,ZZ,Ring)
    (truncate,List,Ring)
  Headline
    truncation of the graded ring, ideal or module at a specified degree or set of degrees
  Usage
    truncate(d,M)
  Inputs
    d:ZZ
      or a single multi-degree or a list of multi-degrees
    M:Module
      or a ring or an ideal
  Outputs
    :Module
      or ideal, the submodule of M consisting of all elements of (component-wise) degree $\ge i$
  Description
    Text
      The truncation to degree $d$ in the singly graded case of a module (or ring or ideal) is
      generated by all homogeneous elements of degree at least $d$ in $M$.  The resulting
      truncation is minimally generated (assuming that $M$ is graded).
    Example
      R = ZZ/101[a..c];
      truncate(2, R)
      truncate(2,R^1)
      truncate(2,R^1 ++ R^{-3})
      truncate(2, ideal(a,b,c^3)/ideal(a^2,b^2,c^4))
      truncate(2,ideal(a,b*c,c^7))
      M = coker matrix"a,b,c;c,b,a"
      truncate(2, M)
      M/(truncate(2,M))
      for i from 0 to 5 list hilbertFunction(i,oo)
    Text
      The base may be ZZ, or another polynomial ring.  Over ZZ, the generators may not
      be minimal, but they do generate.
    Example
      A = ZZ[x,y,z];
      truncate(2,ideal(3*x,5*y,15))
      trim oo
      truncate(2,comodule ideal(3*x,5*y,15))
    Text
      If {\tt i} is a multi-degree, then the result is the submodule
      generated by all elements of degree (component-wise) greater
      than or equal to $i$.

      The following example finds the 11 generators needed to
      obtain all graded elements whose degrees are component-wise
      at least $\{7,24\}$.
    Example
      S = ZZ/101[x,y,z,Degrees=>{{1,3},{1,4},{1,0}}];
      trunc = truncate({7,24}, S^1 ++ S^{{-8,-20}})
      degrees trunc
    Text
      If  {\tt i} is a list of multi-degrees, then the result is the
      submodule generated by all elements
      of degree (component-wise) greater than or equal to at least one degree in $i$.

      The following example finds the generators needed to obtain
      all graded elements whose degrees which are component-wise at
      least $\{3,0\}$ or at least $\{0,1\}$.  The resulting module is
      also minimally generated.
    Example
      S = ZZ/101[x,y,z,Degrees=>{{1,3},{1,4},{1,0}}];
      trunc = truncate({{3,0},{0,1}}, S^1 ++ S^{{-8,-20}})
      degrees trunc
    Text
      The coefficient ring may also be a polynomial ring.  In this
      example, the coefficient variables also have degree one.  The
      given generators will generate the truncation over the
      coefficient ring.
    Example
      B = R[x,y,z, Join=>false]
      degree x
      degree B_3
      truncate(2, B^1)
      truncate(4, ideal(b^2*y,x^3))
    Text
      If the coefficient variables have degree 0:
    Example
      A1 = ZZ/101[a,b,c,Degrees=>{3:{}}]
      degree a
      B1 = A1[x,y]
      degrees B1
      truncate(2,B1^1)
      truncate(2, ideal(a^3*x, b*y^2))
  Caveat
    The behavior of this function has changed as of Macaulay2
    version 1.13.  This is a (potentially) breaking change.  Before,
    it used a less useful notion of truncation, involving the heft
    vector, and was often not what one wanted in the multi-graded
    case.  Additionally, in the tower ring case, when the coefficient
    ring had variables of nonzero degree, sometimes incorrect answers
    resulted.

    Also, the function expects a graded module, ring, or ideal, but this is not checked, and
    some answer is returned.
  SeeAlso
    basis
    comodule

Node
  Key
    (truncate, List, Matrix)
    (truncate, ZZ, Matrix)
  Headline
    truncation of a matrix
  Usage
    truncate(degs, f)
  Inputs
    degs:List
      a list of lists of integers (list of degrees), or a list of integers (a single degree),
      or an integer (a singly graded degree)
    f:Matrix
      a graded map between graded modules (not necessarily free modules)
  Outputs
    :Matrix
  Description
    Text
      This function truncates the source and target of $f$, and returns the induced map
      between them.
    Example
      R = ZZ/101[a..d, Degrees=>{{1,3},{1,0},{1,3},{1,2}}]
      C = res coker vars R
      g1 = truncate({1,1},C.dd_1)
      g2 = truncate({1,1},C.dd_2)
      g3 = truncate({1,1},C.dd_3)
      g4 = truncate({1,1},C.dd_4)
      assert(g1 * g2 == 0)
      assert(g2 * g3 == 0)
      assert(g3 * g4 == 0)
    Text
      This functor is exact.
    Example
      assert(ker g1 == image g2)
      assert(ker g2 == image g3)
      assert(ker g3 == image g4)
  SeeAlso
    (truncate, List, Module)
///

end--

doc ///
Node
  Key
  Headline
  Usage
  Inputs
  Outputs
  Description
    Text
    Example
  Caveat
  SeeAlso
///
