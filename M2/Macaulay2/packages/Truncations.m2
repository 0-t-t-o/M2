-- TODO:
--  1. this should work under quotient rings, exterior algebras, 
--  2. this should be fast for singly graded cases
--  3. make sure doc for the internal routine is correct: 
--      calls basis with an obscure undocumented option.
--      and the result is wrong for multi-gradings
--      and the doc for truncate is incorrect.
--  4. heft vector: we are doing WAY TOO MUCH work here.
--     heft vector doesn't need to be inside the cone.
--     perhaps start with simplicial part of the cone
newPackage(
        "Truncations",
        Version => "0.1", 
        Date => "12 Oct 2018",
        Authors => {
            {
                Name => "David Eisenbud", 
                Email => "de@msri.org", 
                HomePage => "http://www.msri.org/~de"},
            {
                Name => "Mike Stillman", 
                Email => "mike@math.cornell.edu", 
                HomePage=>"http://www.math.cornell.edu/~mike"}
            },
        Headline => "truncation of a module",
        PackageExports => {"Polyhedra"},
        DebuggingMode => true
        )

export {
    "trunc",
    "truncationPolyhedron",
    "basisPolyhedron",
    "Exterior"
    }

truncationPolyhedron = method(Options=>{Exterior => false})
truncationPolyhedron(Matrix, List) := Polyhedron => opts -> (A, b) -> (
    truncationPolyhedron(A, transpose matrix{b}, opts)
    )
truncationPolyhedron(Matrix, Matrix) := Polyhedron => opts -> (A, b) -> (
    if ring A === ZZ then A = A ** QQ;
    if ring A =!= QQ then error "expected matrix over ZZ or QQ";
    I := id_(source A);
    z := map(source A, QQ^1, 0);
    if opts.Exterior then (
        -- also need to add in the conditions that each variable is <= 1.
        -- x <= 1
        ones := matrix toList((numcols A) : {1_QQ});
        polyhedronFromHData(-(A || I) || I, -(b || z) || ones)
        )
    else 
        polyhedronFromHData(-(A || I), -(b || z))
    )

basisPolyhedron = method()
basisPolyhedron(Matrix,List) := (A,b) -> (
    basisPolyhedron(A, transpose matrix{b})
    )
basisPolyhedron(Matrix,Matrix) := (A,b) -> (
    if ring A === ZZ then A = A ** QQ;
    if ring A =!= QQ then error "expected matrix over ZZ or QQ";
    I := id_(source A);
    z := map(source A, QQ^1, 0);
    polyhedronFromHData(-I, -z, A, b)
    )

trunc = method()
trunc(List,Module) := (D,M)->(
    --D can be a list of integers, of length = degreeLength ring M,
    --representing a single multi-degree, or a list of lists of multidegrees.
    --the function returns the submodule of M monomials of degree >=d for some d in D
    --requires that all the components of the degrees of R are all >=0.
    R := ring M;

    --in the easy case of a multiprojective space, don't bother with the aux ring.
    deglist := R_*/degree;
    if all(deglist, d->(sum d == 1 and all(d, i-> i>=0))) then return trunc0(D,M);

    --construct an embedding phi1 of R into a standard graded auxilliary ring:
    n := numgens R;
    dl := degreeLength R;
    --make a new ring T with n*dl variables, one for each (variable,degree component).
    kk := coefficientRing R;
    t := symbol t;
    T := kk[t_(0,0)..t_(n-1,dl-1)];
   --define a map R->T
    e:=0;
    targ := apply(numgens R, i -> (
	e = degree R_i;
	product(dl,j->t_(i,j)^(e_j))
	    ));
    phi1 := map(T,R,targ);

    --now construct the truncation, using the ring map over and over    
    if class D_0 =!= List then (
        L := gens M;
        dM := (degrees (gens M))_1;
        M1 := apply(#dM, i-> 
	    trunc(positivePart(D-dM_i),phi1)*image(L_{i}));
        trim sum M1
        )
    else
        trim sum(D, d->trunc(d,M))
    )

positivePart = method()
positivePart List := L -> apply(L, ell-> max(ell,0))

trunc0 = method()
trunc0(List, Module) := (D,M) ->(
    --A fix for the basic truncate command in the case of a module on multi-projective space.
    --If i is a multi-degree, then the result of truncate(i,M)
    --should be the submodule generated by all elements of degree >= i in the partial order.
    --The script assumes that the degrees of the variables in ring M are the basis vectors,
    --not something more exotic.
    if class D_0 =!= List then (
    dl := degreeLength M;
    L := gens M;
    dM := (degrees (gens M))_1;
    if all(dM, m -> all(dl, i-> m_i<=D_i)) then return image basis(D,M);
    S := ring M;
    M1 := apply(#dM, i-> 
	    ideal(basis(positivePart(D-dM_i),S,Truncate=>true))*image (L_{i}));
    sum M1) else
    trim sum(D, d->trunc0(d,M))
    )

-- The following routine should use integer point polyhedral code, as in normaliz?
trunc(List,RingMap) := (d,phi) ->(
    --for the moment we need T to be of the special form greated in trunc(List, Ring):
    --namely, variable t_(i,j) etc.
    --note that t_(i,j) = T_(i+n*j).
    R := source phi;
    n := numgens R;
    dl := degreeLength R;
    T := target phi;
    -- should have n*dl variables t_(i,j), 0<=i<=n-1, and 0<=j<=dl-1 -- that is,
    -- one for each pair (variable, degree component).
    -- now find the ideal in T of elements of degree >= d.
    -- Td := product(dl,j->(ideal(apply(n,i->t_(i,j))))^(d_j));
    Td := product(dl,j->(ideal(apply(n,i->T_(i+n*j))))^(d_j));
    -- the desired ideal is a kernel
    ker(map(T/Td,T)*phi)  -- TODO: this is a monomial map, use normaliz. or oerhaps make kernel faster.
    )

trunc(List, Ring) := (d,R) ->(
    --produce the ideal in R of all monomials of degree >=D
    --requires that all the components of the degrees of R are all >=0.
    n := numgens R;
    dl := degreeLength R;
    --make a new ring T with n*dl variables, one for each (variable,degree component).
    kk := coefficientRing R;
    t := symbol t;
    skewvarsT := if not R.?SkewCommutative then {} 
                 else (
                    skewvarsR := R.SkewCommutative;
                    flatten for i in skewvarsR list for j from 0 to dl-1 list t_(i,j)
                    );
    T := kk[t_(0,0)..t_(n-1,dl-1), SkewCommutative=>skewvarsT];
      
   --now find the ideal Td in T of elements of degree >= d.
    Td := product(dl,j->(ideal(apply(n,i->t_(i,j))))^(d_j));
   --define a map R->T
    e:=0;
    targ := apply(numgens R, i -> (
	e = degree R_i;
	product(dl,j->t_(i,j)^(e_j))
	    ));
    phi1 := map(T,R,targ);
       --the desired ideal is a kernel of the composite map R --> T/Td.
    U := T ** R;
    Utarg := ideal apply(numgens R, i -> (
	e = degree R_i;
	sub(R_i,U) - sub(product(dl,j->t_(i,j)^(e_j)),U)
        ));
    J := Utarg + sub(Td, U);
    return trim ideal sub(selectInSubring(1, gens gb J), R);
    psi := map(T/Td,T)*phi1;
    psi
    --ker psi
    )

TEST ///
  S = ZZ/101[a,b, Degrees =>{{0,1},{1,0}}]
  M = S^{-{5,2}, -{2,3}}
  D = {4,3}
  E = {{4,3},{3,4}}
  assert(trunc(D,S) == ideal(a^3*b^4))
  assert(trunc(D,S^1) == image matrix {{a^3*b^4}})
  assert(trunc(E,S^1) == image matrix {{a^3*b^4, a^4*b^3}})
  assert(trunc(E,M) == image(map(S^{{-5, -2}, {-2, -3}},, {{0, 0, a}, {b^2, a*b, 0}})))
-*
  trunc0(D,S^1)
  trunc0(D,M)
  trunc(D,M)
  trunc0(E,M)
*-
///

-- truncate the graded ring A in degrees >= d.
-- stash the result.
truncate(List, Ring) := Module => (d, R) -> (
    if not R#?(symbol truncate, d) then R#(symbol truncate, d) = (
      -- TODO: check that d is a degree for the ring R
      A := transpose matrix degrees R;
      P := truncationPolyhedron(A,transpose matrix{d});
      C := cone P;
      H := hilbertBasis C;
      H = for h in H list flatten entries h;
      conegens := rsort for h in H list if h#0 === 0 then R_(drop(h,1)) else continue;
      print matrix {conegens};
      gens := for h in H list if h#0 === 1 then R_(drop(h,1)) else continue;
      image matrix {gens}
      );
    R#(symbol truncate, d)
    )

truncate(List, Module) := Module => (d, F) -> (
    if isFreeModule F then (
        image map(F,,directSum for a in degrees F list gens truncate(d-a,ring F))
        )
    else
        error "not yet implemented"
    )

truncate(List, Matrix) := (d, phi) -> (
    -- this is the case when source and target of phi are free modules...
    F := truncate(d, source phi);
    G := truncate(d, target phi);
    f := gens F;
    g := gens G;
    (phi * f) // g
    )

TEST ///
-*
  restart
  needsPackage "Truncations" 
*-
  S = ZZ/101[a,b, Degrees =>{{0,1},{1,0}}]
  M = S^{-{5,2}, -{2,3}}
  D = {4,3}
  assert(truncate(D,S) == image matrix{{a^3*b^4}})
-- needs to be written
--  E = {{4,3},{3,4}}
--  truncate(E,S)

-*
  trunc0(D,S^1)
  trunc0(D,M)
  trunc(D,M)
  trunc0(E,M)
*-
///

TEST ///
-*
  restart
  debug needsPackage "Truncations" 
*-
  S = ZZ/101[a,b,c,d,e,Degrees=>{3,4,5,6,7}]
  sort gens truncate({8},S) == sort gens trunc({8},S^1)
  truncate({8},S^{-4})
  truncate({8},S^{3})
  truncate({8},S^{-4,-5,-3})
  truncate(8,S^{-4,-5,-3})
  phi = random(S^{-1,-2,-3}, S^{-1,-2,-3,-4,-8})
  psi = truncate({8}, phi)
  assert(isHomogeneous psi)
  -- How best to test this??
///


TEST ///
-*
  restart
  debug needsPackage "Truncations" 
*-
  S = ZZ/101[a,b,c,d,e, Degrees=>{3:{1,0},2:{0,1}}]
  assert(sort gens truncate({1,2},S) == sort gens trunc({1,2},S^1))
  assert(sort gens truncate({1,2},S) == sort gens trunc0({1,2},S^1))
///

TEST ///
-*
  restart
  debug needsPackage "Truncations"
*-
  needsPackage "NormalToricVarieties"
  V = smoothFanoToricVariety(3,5)
  rays V
  max V
  S = ring V
  A = transpose matrix degrees S
  truncate({1,1,1}, S)
  basis({1,1,1},S)
  C = posHull A
C2 = dualCone C
rays C2
///

TEST ///
  -- example 2.  A simple one in one dimension
-* 
  restart  
  needsPackage "Truncations"
*-
  A = matrix {{1,2,3,7,8}}
  b = matrix {{6}}
  P = truncationPolyhedron(A,b)
  -- how to use this?
  
  C = cone P -- this is the cone with P at height 1.
  rays C -- TODO: check this
  facets C -- TODO: check this
  hilbertBasis C
  -- It has two kinds of elements in the Hilbert basis, those at height 
  -- zero, and those at height one in the polyhedron
  R = select(hilbertBasis C, h -> h_(0,0) == 0)
  M = select(hilbertBasis C, h -> h_(0,0) == 1)
  -- Cut off first coordinate
  R = apply(R, r->r^{1..(numRows r-1)})
  M = apply(M, m->m^{1..(numRows m-1)})
  
  Q = basisPolyhedron(A,b)
  isCompact Q -- true
  latticePoints Q
  latticePoints P
  
  PE = truncationPolyhedron(A,b,Exterior=>true)
  cone PE
  hilbertBasis oo
  for h in oo list flatten entries h
  select(oo, h -> h#0 == 1)
  matrix oo
  vertices PE -- I think this works in the exterior case...
///  


TEST ///
  kk = ZZ/101
  R = kk[a,b,c,Degrees =>{2:{3,4},{7,5}}]
  d = {5,6}
  D = {d,reverse d}

  elapsedTime J = trunc(d,R)
  M = R^1
  J = trunc(d,R^1)
  J_*/degree
  K = trunc(D,R^1)
///


beginDocumentation()
end--

doc ///
Key
  Truncation
Headline
Description
  Text
  Example
Caveat
SeeAlso
///

doc ///
Key
Headline
Usage
Inputs
Outputs
Consequences
Description
  Text
  Example
  Code
  Pre
Caveat
SeeAlso
///

TEST ///
-- test code and assertions here
-- may have as many TEST sections as needed
///

end--
restart
loadPackage "Truncations"

-- how to create Ax >= b, x >= 0?
-----------------------------------------------------------------------
---- notes taken by MS and DE in October 2018 for to do for this package
-----------------------------------------------------------------------
restart
load "trunc.m2"
R = ZZ/101[a..d, Degrees=>{3,5,7,9}]
trunc({15}, R)

E = ZZ/101[e_0..e_10, SkewCommutative => true]
trunc0({10}, E^1)
trunc0({11}, E^1)
trunc({3}, E)

gens gb oo

U = E ** T

-------
in trunc(List,Module):
  make the ring U directly, not T.
  instead of phi1, make the ideal we had in trunc(List,Ring).
  
1. change all multi-degrees to be positive. (utility routine)
2. handle quotient rings and modules over them
3. handle exterior algebra
4. trunc creates a ring, which should perhaps be skew commutative.
6. incorporate trunc-new into this package Truncation.

What we really want, is generators for the semigroup
{x in ZZ^n(>=0), Ax >= b}

-- mike doodling about fixing basis command in engine:
Matrix::basis
  KBasis::k_basis(7 arguments)

  
How best to find
  {x in ZZ^n(>=0), Ax = b}
  
  x in ZZ^n
  A is d x n.
  b is in ZZ^d.
  
  Find lattice points in Ax=b, x >= 0.
  
  if possible, Let A1 = Q^-1 * A * P (or A_perm) = (I | C), C is d x (n-d).
  then create a polytope in (n-d) space, then extend each monomial to ZZ^n.
  
-- given a matrix A, d x n whose columns are the degrees of the variables (in ZZ^d),
-- find, if possible a minor with det +-1.  If none, how to handle this?


-- notes 10 Nov 2018, DE, MS
want to solve systems of linear equalities and inequalities in ZZ^n

specifically:
  A be the degree matrix (d x n, n = #vars)
  
  truncate(R, D), D in ZZ^d.
  solve Ax >= D, (might include x >= 0)

  truncate(M, D), M = module.
    take each generator degree E, take Ax >= D-E, then mult each gen
    in degree E by these monomials.


-------------------------------------
-- From an email of Lars Kastner, 10 Nov 2018, in response to a question
-- I (MES) asked him: How to compute generators for the semigroup
--  Ax >= b, x >= 0.
-- Also, find all of the lattice points of Ax=b, x >= 0.
  
Take A={{1,1}} and b={{1/2}}. This gives in your description the two-
dimensional positive orthant without some part of its apex. So the
origin is missing from the lattice points. Then in M2 you can:

loadPackage "Polyhedra"
A = matrix {{1,1}}
b = matrix {{1/2}}
-- The second kind of inequalities, i.e. x>=0
I = matrix map(QQ^2,QQ^2,1)
z = matrix map(QQ^2, QQ^1, 0)
-- Polyhedra uses outer normals for polyhedra, so we have to change the
-- sign. This creates Ax>=b, x>=0/
P = polyhedronFromHData (-(A||I), -(b||z))
-- Consider the cone with the polyhedron at height one
C = cone P
facets C
hilbertBasis C
-- It has two kinds of elements in the Hilbert basis, those at height 
-- zero, and those at height one in the polyhedron
R = select(hilbertBasis C, h -> h_(0,0) == 0)
M = select(hilbertBasis C, h -> h_(0,0) == 1)
-- Cut off first coordinate
R = apply(R, r->r^{1..(numRows r-1)})
M = apply(M, m->m^{1..(numRows m-1)})

Now any lattice point of P is a sum of exactly one element of M and an
arbitrary positive linear combination of elements of R.

Explanation:
C contains all points (h, x) such that -hb+Ax>=0 and -hz+Ix>=0 (+
h>=0). The lattice points you want are those with h=1. You get those by
taking one element of the Hilbert basis with h=1, and adding
arbitrarily many Hilbert basis elements with h=0.


2. Another example:
Pick A={{1,1}} and b={{1}} (almost as above).

Package "Polyhedra"
A = matrix {{1,1}}
b = matrix {{1}}
I = matrix map(QQ^2,QQ^2,1)
z = matrix map(QQ^2, QQ^1, 0)
-- Create polyhedron x>=0, Ax=b
-- This time, A and b describe equations:
P = polyhedronFromHData (-I, -z, A, b)
latticePoints P

Caveat: Ax=b, x>=0 might have infinite solutions anyway. You can check
with 'isCompact P'. Last example:

loadPackage "Polyhedra"
A = matrix {{1,0}}
b = matrix {{1}}
I = matrix map(QQ^2,QQ^2,1)
z = matrix map(QQ^2, QQ^1, 0)
-- Create polyhedron x>=0, Ax=b
P = polyhedronFromHData (-I, -z, A, b)
-- This time, P is not compact
isCompact P
C = cone P
-- inequalities of points in C (note that cones use inner normals)
facets C
-- equations of points in C
hyperplanes C
M = select(hilbertBasis C, h -> h_(0,0) == 1)
M = apply(M, m->m^{1..(numRows m-1)})
R = select(hilbertBasis C, h -> h_(0,0) == 0)
R = apply(R, r->r^{1..(numRows r-1)})

Now every lattice point of P is the sum of exactly one element of M and
an arbitrary positive integral sum of elements of R.

Explanation:
In this case, C contains all points (h, x) such that hb-Ax=0 and
-hz+Ix>=0 (+ h>=0). Then the argument should be as above.


------------------
-- MES examples --
------------------
restart  
needsPackage "Truncations"
-- test of normaliz, to see if it does what we need here:
needsPackage "NormalToricVarieties"

TEST ///
  -- example 1.  A simple one, from Lars' email.
-* 
  restart  
  needsPackage "Truncations"
*-
  A = matrix {{1,1}}
  b = matrix {{1/2}}
  P = truncationPolyhedron(A,b)
  -- how to use this?
  
  C = cone P -- this is the cone with P at height 1.
  rays C -- TODO: check this
  facets C -- TODO: check this
  hilbertBasis C
  -- It has two kinds of elements in the Hilbert basis, those at height 
  -- zero, and those at height one in the polyhedron
  R = select(hilbertBasis C, h -> h_(0,0) == 0)
  M = select(hilbertBasis C, h -> h_(0,0) == 1)
  -- Cut off first coordinate
  R = apply(R, r->r^{1..(numRows r-1)})
  M = apply(M, m->m^{1..(numRows m-1)})
///  


V = smoothFanoToricVariety(3,5)
rays V
max V
S = ring V
A = transpose matrix degrees S
C = posHull A
C2 = dualCone C
rays C2

-- Consider degree (3,2,1)
b = transpose matrix{{3,2,1}}
-(A || id_(QQ^6)), - (b || map(QQ^6, QQ^1, 0))
P = polyhedronFromHData (-(A || id_(QQ^6)), - (b || map(QQ^6, QQ^1, 0)))
vertices P
isCompact P
C = cone P
rays C
facets C
hilbertBasis C
-- It has two kinds of elements in the Hilbert basis, those at height 
-- zero, and those at height one in the polyhedron
R = select(hilbertBasis C, h -> h_(0,0) == 0)
M = select(hilbertBasis C, h -> h_(0,0) == 1)
-- Cut off first coordinate
R = apply(R, r->r^{1..(numRows r-1)})
M = apply(M, m->m^{1..(numRows m-1)})

-- now try Ax = b, x >= 0
I = id_(QQ^6)
z = map(QQ^6, QQ^1, 0)
P = polyhedronFromHData (-I, -z, A, b)
latticePoints P
isCompact P
S = ZZ/101[a..f, Degrees=>entries transpose A]
basis({3,2,1},S)
P = polyhedronFromHData(-id_(QQ^6), -map(QQ^6, QQ^1, 0), A, transpose matrix {{20,5,10}});
LP = elapsedTime latticePoints P; -- slower than one below:
elapsedTime basis({20,5,10}, S);
