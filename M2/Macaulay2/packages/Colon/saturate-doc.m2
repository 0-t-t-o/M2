undocumented {
    (saturate, Thing, Number),
    (saturate, Ideal, List),
    (saturate, Vector),
    (saturate, Vector, Ideal),
    (saturate, Vector, RingElement)
    }

doc ///
Node
  Key
    saturate
   (saturate, Ideal)
   (saturate, Ideal, Ideal)
   (saturate, Ideal, RingElement)
   (saturate, MonomialIdeal, RingElement)
   (saturate, Module)
   (saturate, Module, Ideal)
   (saturate, Module, RingElement)
   [saturate, MinimalGenerators]
  Headline
    saturation of ideal or submodule
  Usage
    saturate(I, J)
    saturate I
  Inputs
    I:{Ideal,MonomialIdeal,Module}
    J:{Ideal,MonomialIdeal,Module,RingElement}
      if not present, then the ideal generated by the variables of the ring is used
    MinimalGenerators=>Boolean
      if false, the output will not be minimalized
  Outputs
    :{Ideal,Module}
      the saturation $I:J^\infty = \{f | f J^N\subset I \text{ for some } N>0\}$
  Description
    Text
      If $I$ is either an ideal or a submodule of a module $M$, the saturation $I : J^\infty$ is defined to be the
      set of elements $f$ in the ring or $M$ such that $f J^N$ is contained in $I$, for some $N$ large enough.

      For example, one way to homogenize an ideal is to homogenize the generators
      and then saturate with respect to the homogenizing variable.
    Example
      R = ZZ/32003[a..d];
      I = ideal(a^3-b, a^4-c)
      Ih = homogenize(I,d)
      saturate(Ih,d)
    Text
      We can use this command to remove graded submodules of finite length.
    Example
      m = ideal vars R
      M = R^1 / (a * m^2)
      M / saturate 0_M
    Text
      If $I$ and $J$ are both monomial ideals, then a faster algorithm is used.
      -- FIXME
      Otherwise, when needed, Gröbner bases will be computed and cached, though the result of the saturation is
      currently not stored anywhere: this means that the computation cannot be continued after an interrupt.
      This will be changed in a later version.
  SeeAlso
    (quotient, Ideal, Ideal)
    "PrimaryDecomposition::PrimaryDecomposition"

Node
  Key
    [saturate, Strategy]
  Description
    Text
      There are four strategy values:
    Code
      SUBSECTION "Iterate",
	TT "saturate(I,J,Strategy => Iterate)", " -- indicates that successive ideal
	or module quotients should be used.",
	PARA{},
	"This value is the default.",
      SUBSECTION "Linear",
	TT "saturate(I,J,Strategy => Linear)",
	TT "Strategy => Linear", " -- indicates that the reverse lex order should
	be used to compute the saturation.",
	PARA{},
	"This presumes that ", TT "J", " is a single, linear polynomial, and that ", TT "I", "
	is homogeneous.",
      SUBSECTION "Bayer",
	TT "saturate(I,f,Strategy => Bayer)", " -- indicates that the method of Bayer's
	thesis should be used.",
	PARA{},
	"The method is to compute ", TT "(I:f)", " for ", TT "I", " and ", TT "f", " homogeneous,
	add a new variable ", TT "z", ", compute a Gröbner basis of ", TT "(I,f-z)", " in reverse
	lex order, divide by ", TT "z", ", and finally replace ", TT "z", " by ", TT "f", ".",
      SUBSECTION "Elimination",
	TT "saturate(I,f,Strategy => Elimination)", " -- indicates that the
	saturation ", TT "(I:f)", " should be computed by eliminating
	f", TT "z", " from ", TT "(I,f*z-1)", ", where ", TT "z", " is a new variable."
///

-*
doc ///
  Key
     saturationZero
    (saturationZero,Module,Ideal)
    (saturationZero,Ideal,Ideal)
  Headline
    checks whether the saturation of a module with respects to a given ideal is zero
  Usage
    saturationZero(M, B)
    saturationZero(I, B)
  Inputs
    M:Module
    B:Ideal
    I:Ideal
  Outputs
    :Boolean
  Description
    Text
      Given an module M and an ideal B saturationZero checks whether the saturation of M by B is zero. If it is
      saturationZero returns true otherwise it returns false. This is done without computing the saturation of M by B.
      Instead we check whether for each generator of B some power of it annihilates the module M. We do this
      generator by generator.

      If M is an ideal saturationZero checks whether the saturation comodule of M by B is zero.
///
*-
