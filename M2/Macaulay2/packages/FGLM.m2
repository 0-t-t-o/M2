newPackage(
        "FGLM",
        Version => "1.0.0",
        Date => "January 29, 2019",
        Authors => {{Name => "Dylan Peifer",
                     Email => "djp282@cornell.edu",
                     HomePage => "https://www.math.cornell.edu/~djp282"}},
        Headline => "Compute Groebner bases via the FGLM algorithm",
        DebuggingMode => true
        )

-*
Copyright (C) 2019 Dylan Peifer

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*-

export {"fglm"}

-------------------------------------------------------------------------------
--- top level functions
-------------------------------------------------------------------------------
fglm = method()
fglm(Ideal, Ring) := GroebnerBasis => (I, R) -> (
    -- I = an ideal
    -- R = a polynomial ring
    -- returns Groebner basis of the ideal I in the ring R
    
    fglm(gb I, R)
    )
fglm(GroebnerBasis, Ring) := GroebnerBasis => (G1, R2) -> (
    -- G1 = a Groebner basis for I in R1
    -- R2 = a polynomial ring
    -- returns Groebner basis of the ideal generated by G in the ring R

    R1 := ring G1;
    I1 := ideal gens G1; -- TODO: find a way to avoid recomputing GB
    if R1 == I1 then return forceGB(sub(gens G1, R2));

    B1 := basis (R1/I1);
    M := multiplicationMatrices G1;
    n := length M;
    m := numcols M#0;

    G2 := {};
    B2 := {1_R2};
    
    V := new MutableHashTable from {
	 B2#0 => transpose matrix { {1_(coefficientRing R1)} | toList ((m-1):0) } 
	 };

    -- TODO: use a heap
    -- TODO: use a hash table
    S := new List from for i from 0 to #gens R2 - 1 list (R2_i * 1_R2, i, 1_R2);
    
    while #S > 0 do (
	print "hi";
	(elt, i, mu) := min S;
	v := M#i * V#mu;
	
	VS := matrix { for s in B2 list V#s };
	if v % VS == 0 then ( -- rank(VS | v) == numcols VS
	    lambda := solve(VS, v); -- syz(VS | v, SyzygyRows => numcols VS);
	    g := elt - matrix {B2} * lambda;
	    G2 = append(G2, g);
    	    S = select(S, s -> s#0 % elt != 0);
	    ) else (
	    B2 = append(B2, mu);
	    S = S | for j from 0 to #gens R2 - 1 list (R2_j * mu, j, mu);
	    S = select(S, s -> all(B2, b -> b != s#0)); -- TODO: think more about this
	    V#mu = v;
	    );
	);
    forceGB(matrix G2)
    )

multiplicationMatrices = method()
multiplicationMatrices(GroebnerBasis) := List => (G) -> (
    -- G = a GroebnerBasis
    -- returns the matrices giving multiplication by variables in R/I

    R := ring G;
    I := ideal gens G;
    B := basis (R/I); -- TODO: find a way to avoid recomputing GB

    mons := first entries B;
    mats := {};

    for x in gens R do (
	F := first entries (x * B);
	M := transpose matrix for f in F list for m in mons list f_m;
	mats = append(mats, M);
    );

    mats
    )

-------------------------------------------------------------------------------
--- documentation
-------------------------------------------------------------------------------
beginDocumentation()

-------------------------------------------------------------------------------
--- tests
-------------------------------------------------------------------------------
TEST ///

///

end


restart
debug needsPackage "FGLM"
R1 = QQ[x,y,z]
I1 = ideal(x*y + z - x*z, x^2 - z, 2*x^3 - x^2*y*z - 1)
G1 = gb I1
B1 = basis (R1/I1)

M = multiplicationMatrices G1

fglm(I1, QQ[x,y,z, MonomialOrder => Lex])
fglm(G1, QQ[x,y,z, MonomialOrder => Lex])

restart
debug needsPackage "FGLM"
R1 = QQ[x,y,z]
I1 = ideal(x^2 + 2*y^2 - y - 2*z, x^2 - 8*y^2 + 10*z - 1, x^2 - 7*y*z)
G1 = gb I1
B1 = basis (R1/I1)


restart
debug needsPackage "FGLM"
R1 = QQ[x,y,z]
I1 = ideal(x^2 + y^2 + z^2 - 2*x, x^3 - y*z - x, x - y + 2*z)
G1 = gb I1
B1 = basis (R1/I1)
