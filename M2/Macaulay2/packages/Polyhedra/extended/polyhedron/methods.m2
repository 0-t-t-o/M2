 -- PURPOSE : Computing the smallest face of 'P' containing 'p'
--   INPUT : '(p,P)',  where 'p' is a point given as a matrix and
--     	    	       'P' is a polyhedron
--  OUTPUT : The smallest face containing 'p' as a polyhedron
smallestFace = method()
smallestFace(Matrix,Polyhedron) := (p,P) -> (
     -- Checking for input errors
     if numColumns p =!= 1 or numRows p =!= ambDim(P) then error("The point must lie in the same space");
     -- p = chkZZQQ(p,"point");
     -- Checking if 'P' contains 'p' at all
     if contains(P,convexHull p) then (
	      (M,v) := halfspaces P;
     	   (N,w) := hyperplanes P;
     	  -- Selecting the half-spaces that fullfil equality for p
	  -- and adding them to the hyperplanes
	  v = promote(v,QQ);
	  pos := select(toList(0..(numRows M)-1), i -> (M^{i})*p == v^{i});
	  N = N || M^pos;
	  w = w || lift(v^pos,ZZ);
	  intersection(M,lift(v,ZZ),N,w))
     else emptyPolyhedron ambDim(P))



-- PURPOSE : Checks if the polytope is normal
--   INPUT : 'P'  a Polyhedron, which must be compact
--  OUTPUT : 'true' or 'false'
-- COMMENT : The polytope is normal if the lattice of the cone over the polytope embedded on height 1 
--     	     is generated by the lattice points on height 1
isNormal Polyhedron := P -> getProperty(P, computedNormal)


-- PURPOSE : Computing the Ehrhart polynomial of a polytope
--   INPUT : 'P',  a polyhedron which must be compact, i.e. a polytope
--  OUTPUT : A polynomial in QQ[x], the Ehrhart polynomial
-- COMMENT : Compactness is checked within latticePoints
ehrhart = method(TypicalValue => RingElement)
ehrhart Polyhedron := P -> getProperty(P, computedEhrhart)


-- PURPOSE : Computing the polar of a given polyhedron
--   INPUT : 'P',  a Polyhedron
--  OUTPUT : A Polyhedron, the set { v | v*p<=1 forall p in P}
polar = method(TypicalValue => Polyhedron)
polar Polyhedron := P -> getProperty(P, computedPolar)


-- PURPOSE : Checks if a polytope is very ample
--   INPUT : 'P'  a Polyhedron, which must be compact
--  OUTPUT : 'true' or 'false'
isVeryAmple = method()
isVeryAmple Polyhedron := P -> getProperty(P, computedVeryAmple)


-- PURPOSE : Computing the vertex-edge-matrix of a polyhedron
--   INPUT : 'P',  a polyhedron
--  OUTPUT : a matrix, where the columns are indexed by the edges and the rows indexed by the vertices and has 1 as entry
--           if the corresponding edge contains this vertex
vertexEdgeMatrix = method(TypicalValue => Matrix)
vertexEdgeMatrix Polyhedron := P -> (
   -- list the edges and the vertices
   eP := apply(faces(dim P -1,P), f -> f#0);
   nEdge := #eP;
   nVert := numColumns vertices P;
   result := map (ZZ^nVert, ZZ^nEdge, 0);
   result = (matrix {{1..nEdge}}) || result;
   result = (transpose matrix {{0..nVert}}) | result;
   result = mutableMatrix result;
   i := 0;
   for edge in eP do (
      s := edge#0;
      t := edge#1;
      result_(s + 1, i + 1) = 1;
      result_(t + 1, i + 1) = 1;
      i = i+1;
   );
   matrix result
)


-- PURPOSE : Computing the vertex-facet-matrix of a polyhedron
--   INPUT : 'P',  a polyhedron
--  OUTPUT : a matrix, where the columns are indexed by the facets and the rows are indexed by the vertices and has 1 as entry
--           if the corresponding facet contains this vertex
vertexFacetMatrix = method(TypicalValue => Matrix)
vertexFacetMatrix Polyhedron := P -> (
   -- list the facets and the vertices
   fP := apply(faces(1,P), f -> f#0);
   nFacet := #fP;
   nVert := numColumns vertices P;
   result := map (ZZ^nVert, ZZ^nFacet, 0);
   result = (matrix {{1..nFacet}}) || result;
   result = (transpose matrix {{0..nVert}}) | result;
   result = mutableMatrix result;
   i := 0;
   for facet in fP do (
      for v in facet do (
         result_(v + 1, i + 1) = 1;
      );
      i = i+1;
   );
   matrix result
)
