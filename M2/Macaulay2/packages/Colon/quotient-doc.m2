///
-- old, replaced documentation
For ideals, the quotient is the set of ring elements r such that rJ is contained in I.
If I is a submodule of a module M, and J is an ideal, the quotient is the set of
elements m of M such that Jm is contained in I. Finally, if I and J are submodules
of the same module M, then the  result is the set of ring elements r such that rJ is contained in I.

R = ZZ/32003[a..d];
J = monomialCurveIdeal(R,{1,4,7})
I = ideal(J_1-a^2*J_0,J_2-d*c*J_0)
I : J
///

doc ///
Node
  Key
    (quotient, Ideal, Ideal)
    (quotient, Ideal, RingElement)
    (quotient, Module, Ideal)
    (quotient, Module, Module)
    (quotient, Module, RingElement)
    (quotient, MonomialIdeal, MonomialIdeal)
    (symbol:, Ideal, Ideal)
    (symbol:, Ideal, RingElement)
    (symbol:, Module, Ideal)
    (symbol:, Module, Module)
    (symbol:, Module, RingElement)
    (symbol:, MonomialIdeal, MonomialIdeal)
  Headline
    ideal or submodule quotient
  Usage
    quotient(I,J)
    I:J
  Inputs
    I:
      an ideal or a submodule
    J:
      an ideal, submodule, or a ring element
  Outputs
    :
      the ideal or submodule quotient $I:J = \{f | fJ\subset I\}$
  Description
    Text
      If @TT "I"@ and @TT "J"@ are both @TO2 (MonomialIdeal,"monomial ideals")@, then the result will be as well.
      If @TT "I"@ and @TT "J"@ are both submodules of the same module, then the result will be an ideal, otherwise
      if @TT "J"@ is an ideal or ring element, then the result is a submodule containing @TT "I"@.
--     "The arguments should be ideals in the same ring, or submodules of the same
--     module.  If ", TT "J", " is a ring element, then the principal ideal 
--     generated by ", TT "J", " is used.",

      Gröbner bases will be computed as needed.

      The colon operator @TO (symbol :)@ may be used as an abbreviation @TT "quotient"@ if no options need to be supplied.
--     "The operator ", TO ":", " can be used as an abbreviation, but without optional
--     arguments; see ", TO (symbol :, Module, Module), ".",

      If the second input @TT "J"@ is a ring element @TT "f"@, then the principal ideal generated by @TT "f"@ is used.

      -- TODO
      The computation is currently not stored anywhere: this means that the computation cannot be continued after
      an interrupt. This will be changed in a later version.
      --The computation is not stored anywhere yet, though it will soon be stored under @TT "I.cache.QuotientComputation{J}"@,
      --or @TT "I.QuotientComputation{J}"@, so that the computation can be restarted after an interrupt.
    Example
      R = ZZ[a,b,c];
      F = a^3-b^2*c-11*c^2
      I = ideal(F,diff(a,F),diff(b,F),diff(c,F))
      I : (ideal(a,b,c))^3
    Text
      If both arguments are submodules, the annihilator of @TT "J/I"@ (or @TT "(J+I)/I"@) is returned.
    Example
      S = QQ[x,y,z];
      J = image vars S
      I = image symmetricPower(2,vars S)
      (I++I) : (J++J)
      (I++I) : x+y+z
      quotient(I,J)
      quotient(gens I, gens J)	  
    Text
      Ideal quotients and saturations are useful for manipulating components of ideals.
    Example
      I = ideal(x^2-y^2, y^3)
      J = ideal((x+y+z)^3, z^2)
      L = intersect(I,J)
      L : z^2
      L : I == J
  SeeAlso
    saturate
    symbol:

Node
  Key
    [quotient, Strategy]
  Headline
    Possible strategies are: Iterate, Linear, and Quotient
  Usage
    quotient(I, J, Strategy => s)
  Inputs
    s:Symbol
      one of @TT " Iterate, Linear, Quotient"@
  Description
    Text
      Suppose that @TT "I"@ is the image of a free module @TT "FI"@ in a quotient module @TT "G"@,
      and @TT "J"@ is the image of the free module @TT "FJ"@ in @TT "G"@.

      The default is @TT "Strategy => Quotient"@, which works as follows:
      compute the first components of the syzygies of

      @PRE "map R++((dual FJ)**FI --> (dual FJ) ** G."@

      If @TT "Strategy => Iterate"@ then quotient first computes the quotient @TT "I1"@ by the first generator of @TT "J"@.
      It then checks whether this quotient already annihilates the second generator of @TT "J mod I"@.
      If so, it goes on to the third generator; else it intersects @TT "I1"@ with the quotient of @TT "I"@ by the second
      generator to produce a new @TT "I1"@. It then iterates this process, working through the generators one at a time.

      To use @TT "Strategy=>Linear"@ the argument @TT "J"@ must be a principal ideal, generated by a linear form.
      A change of variables is made so that this linear form becomes the last variable. Then a reverse lex Gröbner basis
      is used, and the quotient of the initial ideal by the last variable is computed combinatorially.
      This set of monomial is then lifted back to a set of generators for the quotient.

      For further information see for example Exercise 15.41 in Eisenbud's Commutative Algebra with a View Towards Algebraic Geometry.

      The following examples show timings for the different strategies.

      @TT "Strategy => Iterate"@ is sometimes faster for ideals with a small number of generators:
    Example
      n = 6  
      S = ZZ/101[vars(0..n-1)];
      i1 = monomialCurveIdeal(S, 1..n-1)
      i2 = monomialCurveIdeal(S, 1..n-1)
      j1 = ideal(map(S^1,S^n, (p,q)->S_q^5))
      j2 = ideal(map(S^1,S^n, (p,q)->S_q^5))
      time quotient(i1^3,j1^2,Strategy=>Iterate);
      time quotient(i2^3,j2^2,Strategy=>Quotient);
    Text
      @TT "Strategy => Quotient"@ is faster in other cases:
    Example
      S =ZZ/101[vars(0..4)];
      i =ideal vars S;
      j =ideal vars S;
      i3 = i^3; i5 = i^5;
      j3 = j^3; j5 = j^5;
      time quotient(i5,i3,Strategy=>Iterate);
      time quotient(j5,j3,Strategy=>Quotient);

Node
  Key
    [quotient, MinimalGenerators]
  Headline
    Decides whether quotient computes and outputs a trimmed set of generators; default is true
  Usage
    quotient(I, J, MinimalGenerators => b)
  Inputs
    b:Boolean
      if true, forces trimmed output.
  Description
    Example
      S=ZZ/101[a,b]
      i=ideal(a^4,b^4)
    Text
      The following returns 2 minimal generators (Serre's Theorem: a codim 2 Gorenstein ideal is a complete intersection.)
    Example
      quotient(i, a^3+b^3)
    Text
      Without trimming we'd get 4 generators instead.
    Example
      quotient(i, a^3+b^3, MinimalGenerators => false)
///

for n in {BasisElementLimit, PairLimit, DegreeLimit} do
document {
    Key => [quotient, n],
    PARA {
	"The value for this optional argument is passed through to ", TO gb, " when one of the following methods is used: ",
	TO (quotient, Ideal, Ideal), ", ",
	TO (quotient, Ideal, RingElement), ", ",
	TO (quotient, Module, Ideal), ", ",
	TO (quotient, Module, Module), ", and ",
	TO (quotient, Module, RingElement), "."
	}
    }
