newPackage(
        "FGLM",
        Version => "1.0.0",
        Date => "January 29, 2019",
        Authors => {
	    { Name => "Dylan Peifer", Email => "djp282@cornell.edu", HomePage => "https://www.math.cornell.edu/~djp282" },
	    { Name => "Mahrud Sayrafi", Email => "mahrud@umn.edu", HomePage => "https://math.umn.edu/~mahrud" }
	    },
        Headline => "Compute Groebner bases via the FGLM algorithm",
        DebuggingMode => true
        )

-*
Copyright (C) 2019 Dylan Peifer and Mahrud Sayrafi

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*-

export {"fglm"}

-------------------------------------------------------------------------------
--- top level functions
-------------------------------------------------------------------------------

---------------------------------------------------------------------------
-- See Section 2.4.4 of Thibaut Verron's thesis for details:
-- https://thibautverron.github.io/doc/2016-these.pdf
---------------------------------------------------------------------------
fglm = method()
fglm(Ideal, Ring) := GroebnerBasis => (I, R) -> (
    -- I = an ideal
    -- R = a polynomial ring
    -- returns Groebner basis of the ideal I in the ring R
    
    fglm(gb I, R)
    )
fglm(GroebnerBasis, Ring) := GroebnerBasis => (G1, R2) -> (
    -- G1 = a Groebner basis for I in R1
    -- R2 = a polynomial ring
    -- returns Groebner basis of the ideal generated by G in the ring R

    R1 := ring G1;
    I1 := ideal gens G1; -- TODO: find a way to avoid recomputing GB
    if R1 == I1 then return forceGB(sub(gens G1, R2));

    B1 := basis (R1/I1);
    M := multiplicationMatrices G1;
    m := numcols M#0;
    n := #gens R2 - 1;

    -- elements in the grobner basis
    G2 := {};
    -- elements in the staircase
    B2 := {1_R2};
    
    -- normal form translation table
    V := new MutableHashTable from {
	 B2#0 => transpose matrix { {1_(coefficientRing R1)} | toList ((m-1):0) } 
	 };

    -- list of elements between the staircase and grobner basis generators
    -- TODO: use a heap
    -- TODO: use a hash table
    S := new List from for i to n list (R2_i * 1_R2, i, 1_R2);
    
    while #S > 0 do (
	(elt, i, mu) := min S;
	v := M#i * V#mu;
	
	VS := matrix { for s in B2 list V#s };
	if v % VS == 0 then ( -- rank(VS | v) == numcols VS
	    lambda := solve(VS, v); -- syz(VS | v, SyzygyRows => numcols VS);
	    g := elt - matrix {B2} * lambda;
	    G2 = append(G2, g);
    	    S = select(S, s -> s#0 % elt != 0);
	    ) else (
	    B2 = append(B2, elt);
	    S = S | for j to n list (R2_j * elt, j, elt);
	    S = select(S, s -> all(B2, b -> b != s#0)); -- TODO: think more about this
	    V#elt = v;
	    );
	);
    forceGB(matrix {G2})
    )

multiplicationMatrices = method()
multiplicationMatrices(GroebnerBasis) := List => (G) -> (
    -- G = a GroebnerBasis
    -- returns the matrices giving multiplication by variables in R/I

    R := ring G;
    I := ideal gens G;
    B := basis (R/I); -- TODO: find a way to avoid recomputing GB

    mons := first entries B;
    mats := {};

    for x in gens R do (
	F := first entries (x * B);
	M := transpose matrix for f in F list for m in mons list f_m;
	mats = append(mats, M);
    );

    mats
    )

-------------------------------------------------------------------------------
--- documentation
-------------------------------------------------------------------------------
beginDocumentation()

-------------------------------------------------------------------------------
--- tests
-------------------------------------------------------------------------------
test = (I1, MO2) -> (
    R1 := ring I1;
    R2 := (coefficientRing R1)(monoid ([gens R1], MonomialOrder => MO2));
    elapsedTime G2 := gb(sub(I1, R2));
    elapsedTime G2' := fglm(I1, R2);
    assert(gens G2 == gens G2')
    )

TEST ///
  debug needsPackage "FGLM"
  R1 = QQ[x,y,z]
  I1 = ideal(x*y + z - x*z, x^2 - z, 2*x^3 - x^2*y*z - 1)
  test(I1, Lex)
///

TEST ///
  debug needsPackage "FGLM"
  R1 = QQ[x,y,z]
  I1 = ideal(x^2 + 2*y^2 - y - 2*z, x^2 - 8*y^2 + 10*z - 1, x^2 - 7*y*z)
  test(I1, Lex)
///

TEST ///
  debug needsPackage "FGLM"
  R1 = QQ[x,y,z]
  I1 = ideal(x^2 + y^2 + z^2 - 2*x, x^3 - y*z - x, x - y + 2*z)
  test(I1, Lex)
///

TEST ///
  debug needsPackage "FGLM"
  R1 = QQ[x,y,z]
  I1 = ideal(x*y + z - x*z, x^2 - z, 2*x^3 - x^2*y*z - 1)
  test(I1, Lex)
///

TEST ///
  
///

end

restart
needsPackage "FGLM"
elapsedTime check FGLM -- 4.17 seconds

restart
uninstallPackage "FGLM"
restart
installPackage "FGLM"
viewHelp "FGLM"
