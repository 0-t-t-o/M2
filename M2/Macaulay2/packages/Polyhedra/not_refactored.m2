-- The following contains methods that have only been partially refactored because:
-- * They were too long.
-- * We did not know what they do or
-- * We did not know how they work.
-- * We had no way of testing them at this point.
-- These methods have been fixed to work with the new setup. Use at own risk.


-- PURPOSE : Computing the state polytope of the ideal 'I'
--   INPUT : 'I',  a homogeneous ideal with resect to some strictly psoitive grading
--  OUTPUT : The state polytope as a polyhedron
statePolytope = method(TypicalValue => Polyhedron)
statePolytope Ideal := I -> (
   -- Check if there exists a strictly positive grading such that 'I' is homogeneous with
   -- respect to this grading
   homogeneityCheck := I -> (
      -- Generate the matrix 'M' that spans the space of the differeneces of the 
      -- exponent vectors of the generators of 'I'
      L := flatten entries gens I;
      lt := apply(L, leadTerm);
      M := matrix flatten apply(#L, i -> apply(exponents L#i, e -> (flatten exponents lt#i)-e));
      -- intersect the span of 'M' with the positive orthant
      C := intersection(map(source M,source M,1),M);
      -- Check if an interior vector is strictly positive
      v := interiorVector C;
      (all(flatten entries v, e -> e > 0),v)
   );
   -- Compute the Groebner cone
   gCone := (g,lt) -> (
      -- for a given groebner basis compute the reduced Groebner basis
      -- note: might be obsolete, but until now (Jan2009) groebner bases appear to be not reduced
      g = apply(flatten entries gens g, l -> ((l-leadTerm(l))% g)+leadTerm(l));
      -- collect the differences of the exponent vectors of the groebner basis
      lt = flatten entries lt;
      L := matrix flatten apply(#g, i -> apply(exponents g#i, e -> (flatten exponents lt#i)-e));
      -- intersect the differences
      intersection L
   );
   wLeadTerm := (w,I) -> (
      -- Compute the Groebner basis and their leading terms of 'I' with respect to the weight 'w'
      R := ring I;
      -- Resize w to a primitive vector in ZZ
      w = flatten entries substitute((1 / abs gcd flatten entries w) * w,ZZ);
      -- generate the new ring with weight 'w'
      S := (coefficientRing R)[gens R, MonomialOrder => {Weights => w}, Global => false];
      f := map(S,R);
      -- map 'I' into 'S' and compute Groebner basis and leadterm
      I1 := f I;
      g := gb I1;
      lt := leadTerm I1;
      gbRemove I1;
      (g,lt)
   );
   makePositive := (w,posv) -> (
      w = flatten entries w;
      posv = flatten entries posv;
      j := min(apply(#w, i -> w#i/posv#i));
      if j <= 0 then j = 1 - floor j else j = 0;
      matrix transpose{w + j * posv}
   );
   -- computes the symmetric difference of the two lists
   sortIn := (L1,L2) -> ((a,b) := (set apply(L1,first),set apply(L2,first)); join(select(L1,i->not b#?(i#0)),select(L2,i->not a#?(i#0))));
   --Checking for homogeneity
   (noError,posv) := homogeneityCheck I;
   if not noError then error("The ideal must be homogeneous w.r.t. some strictly positive grading");
   -- Compute a first Groebner basis to start with
   g := gb I;
   lt := leadTerm I;
   -- Compute the Groebner cone
   C := gCone(g,lt);
   gbRemove I;
   -- Generate all facets of 'C'
   -- Save each facet by an interior vector of it, the facet itself and the cone from 
   -- which it has been computed
   raysC := rays C;
   triplets := C -> (
      raysC := rays C;
      linC := linealitySpace C;
      apply(faces(1,C), 
         f -> (
            fCone := posHull(raysC_f, linealitySpace C);
            (interiorVector fCone,fCone,C)
         )
      )
   );
   facets := triplets C;
   --Save the leading terms as the first vertex
   verts := {lt};
   -- Scan the facets
   while facets != {} do (
      local omega';
      local f;
      (omega',f,C) = facets#0;
      -- compute an interior vector of the big cone 'C' and take a small 'eps'
      omega := promote(interiorVector C,QQ);
      eps := 1/10;
      omega1 := omega'-(eps*omega);
      (g,lt) = wLeadTerm(makePositive(omega1,posv),I);
      C' := gCone(g,lt);
      -- reduce 'eps' until the Groebner cone generated by omega'-(eps*omega) is 
      -- adjacent to the big cone 'C'
      while intersection(C,C') != f do (
          eps = eps * 1/10;
          omega1 = omega'-(eps*omega);
          (g,lt) = wLeadTerm(makePositive(omega1,posv),I);
          C' = gCone(g,lt)
      );
      C = C';
      -- save the new leadterms as a new vertex
      verts = append(verts,lt);
      -- Compute the facets of the new Groebner cone and save them in the same way as before
      newfacets := triplets C;
      -- Save the symmetric difference into 'facets'
      facets = sortIn(facets,newfacets)
   );
   posv = substitute(posv,ZZ);
   R := ring I;
   -- generate a new ring with the strictly positive grading computed by the homogeneity check
   S := QQ[gens R, Degrees => entries posv];
   -- map the vertices into the new ring 'S'
   verts = apply(verts, el -> (map(S,ring el)) el);
   -- Compute the maximal degree of the vertices
   L := flatten apply(verts, l -> flatten entries l);
   d := (max apply(flatten L, degree))#0;
   -- compute the vertices of the state polytope
   vertmatrix := transpose matrix apply(verts, v -> (
       VI := ideal flatten entries v;
       SI := S/VI;
       v = flatten apply(d, i -> flatten entries basis(i+1,SI));
       flatten sum apply(v,exponents))
   );
   -- Compute the state polytope
   P := convexHull vertmatrix;
   (verts,P)
);


-- PURPOSE : Computing the closest point of a polyhedron to a given point
--   INPUT : (p,P),  where 'p' is a point given by a one column matrix over ZZ or QQ and
--                   'P' is a Polyhedron
--  OUTPUT : the point in 'P' with the minimal euclidian distance to 'p'
proximum = method(TypicalValue => Matrix)
proximum (Matrix,Polyhedron) := (p,P) -> (
     -- Checking for input errors
     if numColumns p =!= 1 or numRows p =!= ambDim(P) then error("The point must lie in the same space");
     if isEmpty P then error("The polyhedron must not be empty");
     -- Defining local variables
     local Flist;
     d := ambDim P;
     c := 0;
     prox := {};
     -- Checking if 'p' is contained in 'P'
     if contains(P,p) then p
     else (
	  V := vertices P;
	  R := promote(rays P,QQ);
	  -- Distinguish between full dimensional polyhedra and not full dimensional ones
	  if dim P == d then (
	       -- Continue as long as the proximum has not been found
	       while instance(prox,List) do (
		    -- Take the faces of next lower dimension of P
		    c = c+1;
		    if c == dim P then (
			 Vdist := apply(numColumns V, j -> ((transpose(V_{j}-p))*(V_{j}-p))_(0,0));
			 pos := min Vdist;
			 pos = position(Vdist, j -> j == pos);
			 prox = V_{pos})
		    else (
			 Flist = faces(c,P);
			 -- Search through the faces
			 any(Flist, (v, r) -> (
               F := convexHull((vertices P)_v, (rays P)_r, linealitySpace P);
				   -- Take the inward pointing normal cone with respect to P
				   (vL,bL) := hyperplanes F;
				   -- Check for each ray if it is pointing inward
				   vL = matrix apply(numRows vL, i -> (
					     v := vL^{i};
					     b := first flatten entries bL^{i};
					     if all(flatten entries (v*(V | R)), e -> e >= b) then flatten entries v
					     else flatten entries(-v)));
				   -- Take the polyhedron spanned by the inward pointing normal cone 
				   -- and 'p' and intersect it with the face
				   Q := intersection(F,convexHull(p,transpose vL));
				   -- If this intersection is not empty, it contains exactly one point, 
				   -- the proximum
				   if not isEmpty Q then (
					prox = vertices Q;
					true)
				   else false))));
	       prox)
	  else (
	       -- For not full dimensional polyhedra the hyperplanes of 'P' have to be considered also
	       while instance(prox,List) do (
		    if c == dim P then (
			 Vdist1 := apply(numColumns V, j -> ((transpose(V_{j}-p))*(V_{j}-p))_(0,0));
			 pos1 := min Vdist1;
			 pos1 = position(Vdist1, j -> j == pos1);
			 prox = V_{pos1})
		    else (
			 Flist = faces(c,P);
			 -- Search through the faces
			 any(Flist, (v, r) -> (
               F := convexHull((vertices P)_v, (rays P)_r, linealitySpace P);
				   -- Take the inward pointing normal cone with respect to P
				   (vL,bL) := hyperplanes F;
				   vL = matrix apply(numRows vL, i -> (
					     v := vL^{i};
					     b := first flatten entries bL^{i};
					     entryList := flatten entries (v*(V | R));
					     -- the first two ifs find the vectors not in the hyperspace
					     -- of 'P'
					     if any(entryList, e -> e > b) then flatten entries v
					     else if any(entryList, e -> e < b) then flatten entries(-v)
					     -- If it is an original hyperplane than take the direction from 
					     -- 'p' to the polyhedron
					     else (
						  bCheck := first flatten entries (v*p);
						  if bCheck < b then flatten entries v
						  else flatten entries(-v))));
				   Q := intersection(F,convexHull(p,transpose vL));
				   if not isEmpty Q then (
					prox = vertices Q;
					true)
				   else false)));
		    c = c+1);
	       prox)))


--   INPUT : (p,C),  where 'p' is a point given by a one column matrix over ZZ or QQ and
--                   'C' is a Cone
--  OUTPUT : the point in 'C' with the minimal euclidian distance to 'p'
proximum (Matrix,Cone) := (p,C) -> proximum(p,polyhedron C)
