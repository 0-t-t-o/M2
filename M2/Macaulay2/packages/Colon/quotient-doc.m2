undocumented {
    (quotient, Thing, Number), (symbol:, Thing, Number)
    }

doc ///
Node
  Key
-- return an ideal
    (quotient, Ideal, Ideal)
    (quotient, Ideal, RingElement)
    (quotient, MonomialIdeal, MonomialIdeal)
    (symbol:, Ideal, Ideal)
    (symbol:, Ideal, RingElement)
    (symbol:, MonomialIdeal, MonomialIdeal)
-- return a module
    (quotient, Module, Ideal)
    (quotient, Module, RingElement)
    (symbol:, Module, Ideal)
    (symbol:, Module, RingElement)
-- return an ideal
    (quotient, Module, Module)
    (symbol:, Module, Module)
    [quotient, MinimalGenerators]
  Headline
    ideal or submodule quotient
  Usage
    quotient(I, J)
    I:J
  Inputs
    I:{Ideal,MonomialIdeal,Module}
    J:{Ideal,MonomialIdeal,Module,RingElement}
    MinimalGenerators=>Boolean
      if false, the output will not be minimalized
  Outputs
    :{Ideal,Module}
      the quotient $I:J = \{f | f J\subset I\}$
  Description
    Text
      If @TT "I"@ and @TT "J"@ are both @TO2 (MonomialIdeal, "monomial ideals")@, then the result will be as well.
      If @TT "I"@ and @TT "J"@ are both ideals or submodules of the same module, then the result will be an ideal, otherwise
      if @TT "J"@ is an ideal or ring element, then the result is a submodule containing @TT "I"@.

      The arguments should be ideals in the same ring, or submodules of the same module.
      If the second input @TT "J"@ is a ring element @TT "f"@, then the principal ideal generated by @TT "f"@ is used.
      The infix colon operator @TO symbol:@ may be used as an abbreviation, if no options need to be supplied.

      -- TODO: rewrite with math
      For ideals, the quotient is the set of ring elements $r$ such that $rJ$ is contained in $I$.
      If $I$ is a submodule of a module $M$, and $J$ is an ideal, the quotient is the set of elements $m \in M$
      such that $Jm$ is contained in $I$. Finally, if $I$ and $J$ are submodules of the same module $M$,
      then the result is the set of ring elements $r$ such that $rJ$ is contained in $I$.
    Example
      R = ZZ/32003[a..d];
      J = monomialCurveIdeal(R,{1,4,7})
      I = ideal(J_1-a^2*J_0,J_2-d*c*J_0)
      I : J
    Text
      -- FIXME
      When needed, Gröbner bases will be computed and cached, though the result of the quotient computation is
      currently not stored anywhere: this means that the computation cannot be continued after an interrupt.
      This will be changed in a later version.
    Example
      R = ZZ[a,b,c];
      F = a^3-b^2*c-11*c^2
      I = ideal(F,diff(a,F),diff(b,F),diff(c,F))
      I : (ideal(a,b,c))^3
    Text
      If both arguments are submodules of the same module, the annihilator of @TT "J/I"@ (or @TT "(J+I)/I"@) is returned.
    Example
      S = QQ[x,y,z];
      J = image vars S
      I = image symmetricPower(2,vars S)
      (I++I) : (J++J)
      (I++I) : x+y+z
      quotient(I,J)
      quotient(gens I, gens J)
    Text
      Ideal quotients and saturations are useful for manipulating components of ideals.
    Example
      I = ideal(x^2-y^2, y^3)
      J = ideal((x+y+z)^3, z^2)
      L = intersect(I,J)
      L : z^2
      L : I == J
  SeeAlso
    saturate
    symbol:

Node
  Key
    [quotient, Strategy]
  Description
    Text
      Suppose that @TT "I"@ is the image of a free module @TT "FI"@ in a quotient module @TT "G"@,
      and @TT "J"@ is the image of the free module @TT "FJ"@ in @TT "G"@.

      Possible strategies are: Iterate, Linear, and Quotient
      The default is @TT "Strategy => Quotient"@, which works as follows:
      compute the first components of the syzygies of

      @PRE "map R++((dual FJ)**FI --> (dual FJ) ** G."@

      If @TT "Strategy => Iterate"@ then quotient first computes the quotient @TT "I1"@ by the first generator of @TT "J"@.
      It then checks whether this quotient already annihilates the second generator of @TT "J mod I"@.
      If so, it goes on to the third generator; else it intersects @TT "I1"@ with the quotient of @TT "I"@ by the second
      generator to produce a new @TT "I1"@. It then iterates this process, working through the generators one at a time.

      To use @TT "Strategy=>Linear"@ the argument @TT "J"@ must be a principal ideal, generated by a linear form.
      A change of variables is made so that this linear form becomes the last variable. Then a reverse lex Gröbner basis
      is used, and the quotient of the initial ideal by the last variable is computed combinatorially.
      This set of monomial is then lifted back to a set of generators for the quotient.

      For further information see for example Exercise 15.41 in Eisenbud's Commutative Algebra with a View Towards Algebraic Geometry.

      The following examples show timings for the different strategies.

      @TT "Strategy => Iterate"@ is sometimes faster for ideals with a small number of generators:
    Example
      n = 6
      S = ZZ/101[vars(0..n-1)];
      i1 = monomialCurveIdeal(S, 1..n-1)
      i2 = monomialCurveIdeal(S, 1..n-1)
      j1 = ideal(map(S^1,S^n, (p,q)->S_q^5))
      j2 = ideal(map(S^1,S^n, (p,q)->S_q^5))
      time quotient(i1^3,j1^2,Strategy=>Iterate);
      time quotient(i2^3,j2^2,Strategy=>Quotient);
    Text
      @TT "Strategy => Quotient"@ is faster in other cases:
    Example
      S =ZZ/101[vars(0..4)];
      i =ideal vars S;
      j =ideal vars S;
      i3 = i^3; i5 = i^5;
      j3 = j^3; j5 = j^5;
      time quotient(i5,i3,Strategy=>Iterate);
      time quotient(j5,j3,Strategy=>Quotient);
///
