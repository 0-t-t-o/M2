undocumented { (saturate, Vector) }

doc ///
Node
  Key
    saturate
   (saturate, Ideal)
   (saturate, Ideal, Ideal)
   (saturate, Ideal, RingElement)
   (saturate, Module)
   (saturate, Module, Ideal)
   (saturate, Module, RingElement)
   (saturate, MonomialIdeal, MonomialIdeal)
   (saturate, MonomialIdeal, RingElement)
  Headline
    saturation of ideal or submodule
  Usage
    saturate(I,J)
    saturate I
  Inputs
    I:
      an ideal or submodule
    J:
      an ideal, submodule, or ring element.
      If not present, then the ideal generated by the variables of the ring is used
  Outputs
    :
      the ideal or submodule saturation $I:J^\infty = \{f | fJ^n\subset I \text{ for some large enough } n\}$
  Description
    Text
      If I is either an ideal or a submodule of a module M the saturation (I : J^*) is defined to be the set of elements
      f in the ring (first case) or in M (second case) such that J^N * f is contained in I, for some N large enough.

      For example, one way to homogenize an ideal is to homogenize the generators and then saturate with respect to
      the homogenizing variable.
    Example
      R = ZZ/32003[a..d];
      I = ideal(a^3-b, a^4-c)
      Ih = homogenize(I,d)
      saturate(Ih,d)
    Text
      We can use this command to remove graded submodules of finite length.
    Example
      m = ideal vars R
      M = R^1 / (a * m^2)
      M / saturate 0_M
    Text
      If I and J are both monomial ideals, then a faster algorithm is used.  If I or J is not a monomial ideal
      generally Gröbner bases will be used to the compute the saturation.  These will be computed as needed.

      -- TODO
      The computation is currently not stored anywhere: this means that the computation cannot be continued after an interrupt.
      This will be changed in a later version.
  SeeAlso
    quotient
    "PrimaryDecomposition::PrimaryDecomposition"

Node
  Key
    [saturate, Strategy]
  Description
    Text
      There are four strategy values:
    Code
      SUBSECTION "Iterate",
	TT "saturate(I,J,Strategy => Iterate)", " -- indicates that successive ideal
	or module quotients should be used.",
	PARA{},
	"This value is the default.",
      SUBSECTION "Linear",
	TT "saturate(I,J,Strategy => Linear)",
	TT "Strategy => Linear", " -- indicates that the reverse lex order should
	be used to compute the saturation.",
	PARA{},
	"This presumes that ", TT "J", " is a single, linear polynomial, and that ", TT "I", "
	is homogeneous.",
      SUBSECTION "Bayer",
	TT "saturate(I,f,Strategy => Bayer)", " -- indicates that the method of Bayer's
	thesis should be used.",
	PARA{},
	"The method is to compute ", TT "(I:f)", " for ", TT "I", " and ", TT "f", " homogeneous,
	add a new variable ", TT "z", ", compute a Gröbner basis of ", TT "(I,f-z)", " in reverse
	lex order, divide by ", TT "z", ", and finally replace ", TT "z", " by ", TT "f", ".",
      SUBSECTION "Elimination",
	TT "saturate(I,f,Strategy => Elimination)", " -- indicates that the
	saturation ", TT "(I:f)", " should be computed by eliminating
	f", TT "z", " from ", TT "(I,f*z-1)", ", where ", TT "z", " is a new variable."

Node
  Key
    [saturate, MinimalGenerators]
  Headline
    whether to compute minimal generators
  Usage
    saturate(..., MinimalGenerators => b)
  Inputs
    b:Boolean
      if false, then the minimalization of the saturation will not be done
  Description
    Text
      Sometimes the extra time to find the minimal generators is too large.
      This allows one to bypass this part of the computation.
    Example
      R = ZZ/101[x_0..x_4]
      I = truncate(8, monomialCurveIdeal(R,{1,4,5,9}));
      time gens gb I;
      time J1 = saturate(I);
      time J = saturate(I, MinimalGenerators=>false);
      numgens J
      numgens J1
  SeeAlso
    monomialCurveIdeal
    "Truncations::truncate"
///

for n in {BasisElementLimit, PairLimit, DegreeLimit} do
document {
    Key => [saturate, n],
    PARA {
	"The value for this optional argument is passed through to ", TO gb, " when
	one of the following methods is used: ",
	TO (saturate, Ideal), ", ",
	TO (saturate, Ideal, Ideal), ", ",
	TO (saturate, Ideal, RingElement), ", ",
	TO (saturate, Module), ", ",
	TO (saturate, Module, Ideal), ", ",
	TO (saturate, Module, RingElement), ", ",
	TO (saturate, MonomialIdeal, MonomialIdeal), ", and ",
	TO (saturate, MonomialIdeal, RingElement), "."
	}
    }

-*
doc ///
  Key
     saturationZero
    (saturationZero,Module,Ideal)
    (saturationZero,Ideal,Ideal)
  Headline
    checks whether the saturation of a module with respects to a given ideal is zero
  Usage
    saturationZero(M, B)
    saturationZero(I, B)
  Inputs
    M:Module
    B:Ideal
    I:Ideal
  Outputs
    :Boolean
  Description
    Text
      Given an module M and an ideal B saturationZero checks whether the saturation of M by B is zero. If it is
      saturationZero returns true otherwise it returns false. This is done without computing the saturation of M by B.
      Instead we check whether for each generator of B some power of it annihilates the module M. We do this
      generator by generator.

      If M is an ideal saturationZero checks whether the saturation comodule of M by B is zero.
///
*-
