-- TODO:
--  1. this should work under quotient rings, exterior algebras, 
--  2. this should be fast for singly graded cases
--  3. make sure doc for the internal routine is correct: 
--      calls basis with an obscure undocumented option.
--      and the result is wrong for multi-gradings
--      and the doc for truncate is incorrect.
--  4. heft vector: we are doing WAY TOO MUCH work here.
--     heft vector doesn't need to be inside the cone.
--     perhaps start with simplicial part of the cone
newPackage(
        "Truncations",
        Version => "0.1", 
        Date => "12 Oct 2018",
        Authors => {
            {
                Name => "David Eisenbud", 
                Email => "de@msri.org", 
                HomePage => "http://www.msri.org/~de"},
            {
                Name => "Mike Stillman", 
                Email => "mike@math.cornell.edu", 
                HomePage=>"http://www.math.cornell.edu/~mike"}
            },
        Headline => "truncation of a module",
        PackageExports => {"Polyhedra"},
        DebuggingMode => true
        )

export {
    "truncation",
    -- to be made local:
    "trunc",
    "truncationPolyhedron",
    "basisPolyhedron",
    "Exterior"
    }

truncation = method()

truncationPolyhedron = method(Options=>{Exterior => false})
truncationPolyhedron(Matrix, List) := Polyhedron => opts -> (A, b) -> (
    truncationPolyhedron(A, transpose matrix{b}, opts)
    )
truncationPolyhedron(Matrix, Matrix) := Polyhedron => opts -> (A, b) -> (
    -- assumption: A is m x n. b is m x 1.
    -- returns the polyhedron {Ax >= b, x >=0}
    if ring A === ZZ then A = A ** QQ;
    if ring A =!= QQ then error "expected matrix over ZZ or QQ";
    I := id_(source A);
    z := map(source A, QQ^1, 0);
    if opts.Exterior then (
        -- also need to add in the conditions that each variable is <= 1.
        -- x <= 1
        ones := matrix toList((numcols A) : {1_QQ});
        polyhedronFromHData(-(A || I) || I, -(b || z) || ones)
        )
    else 
        polyhedronFromHData(-(A || I), -(b || z))
    )

basisPolyhedron = method()
basisPolyhedron(Matrix,List) := (A,b) -> (
    basisPolyhedron(A, transpose matrix{b})
    )
basisPolyhedron(Matrix,Matrix) := (A,b) -> (
    -- assumption: A is m x n. b is m x 1.
    -- returns the polyhedron {Ax = b, x >=0}
    if ring A === ZZ then A = A ** QQ;
    if ring A =!= QQ then error "expected matrix over ZZ or QQ";
    I := id_(source A);
    z := map(source A, QQ^1, 0);
    polyhedronFromHData(-I, -z, A, b)
    )

trunc = method()
trunc(List,Module) := (D,M)->(
    --D can be a list of integers, of length = degreeLength ring M,
    --representing a single multi-degree, or a list of lists of multidegrees.
    --the function returns the submodule of M monomials of degree >=d for some d in D
    --requires that all the components of the degrees of R are all >=0.
    R := ring M;

    --in the easy case of a multiprojective space, don't bother with the aux ring.
    deglist := R_*/degree;
    if all(deglist, d->(sum d == 1 and all(d, i-> i>=0))) then return trunc0(D,M);

    --construct an embedding phi1 of R into a standard graded auxilliary ring:
    n := numgens R;
    dl := degreeLength R;
    --make a new ring T with n*dl variables, one for each (variable,degree component).
    kk := coefficientRing R;
    t := symbol t;
    T := kk[t_(0,0)..t_(n-1,dl-1)];
   --define a map R->T
    e:=0;
    targ := apply(numgens R, i -> (
	e = degree R_i;
	product(dl,j->t_(i,j)^(e_j))
	    ));
    phi1 := map(T,R,targ);

    --now construct the truncation, using the ring map over and over    
    if class D_0 =!= List then (
        L := gens M;
        dM := (degrees (gens M))_1;
        M1 := apply(#dM, i-> 
	    trunc(positivePart(D-dM_i),phi1)*image(L_{i}));
        trim sum M1
        )
    else
        trim sum(D, d->trunc(d,M))
    )

positivePart = method()
positivePart List := L -> apply(L, ell-> max(ell,0))

trunc0 = method()
trunc0(List, Module) := (D,M) ->(
    --A fix for the basic truncate command in the case of a module on multi-projective space.
    --If i is a multi-degree, then the result of truncate(i,M)
    --should be the submodule generated by all elements of degree >= i in the partial order.
    --The script assumes that the degrees of the variables in ring M are the basis vectors,
    --not something more exotic.
    if class D_0 =!= List then (
    dl := degreeLength M;
    L := gens M;
    dM := (degrees (gens M))_1;
    if all(dM, m -> all(dl, i-> m_i<=D_i)) then return image basis(D,M);
    S := ring M;
    M1 := apply(#dM, i-> 
	    ideal(basis(positivePart(D-dM_i),S,Truncate=>true))*image (L_{i}));
    sum M1) else
    trim sum(D, d->trunc0(d,M))
    )

-- The following routine should use integer point polyhedral code, as in normaliz?
trunc(List,RingMap) := (d,phi) ->(
    --for the moment we need T to be of the special form greated in trunc(List, Ring):
    --namely, variable t_(i,j) etc.
    --note that t_(i,j) = T_(i+n*j).
    R := source phi;
    n := numgens R;
    dl := degreeLength R;
    T := target phi;
    -- should have n*dl variables t_(i,j), 0<=i<=n-1, and 0<=j<=dl-1 -- that is,
    -- one for each pair (variable, degree component).
    -- now find the ideal in T of elements of degree >= d.
    -- Td := product(dl,j->(ideal(apply(n,i->t_(i,j))))^(d_j));
    Td := product(dl,j->(ideal(apply(n,i->T_(i+n*j))))^(d_j));
    -- the desired ideal is a kernel
    ker(map(T/Td,T)*phi)  -- TODO: this is a monomial map, use normaliz. or oerhaps make kernel faster.
    )

trunc(List, Ring) := (d,R) ->(
    --produce the ideal in R of all monomials of degree >=D
    --requires that all the components of the degrees of R are all >=0.
    n := numgens R;
    dl := degreeLength R;
    --make a new ring T with n*dl variables, one for each (variable,degree component).
    kk := coefficientRing R;
    t := symbol t;
    skewvarsT := if not R.?SkewCommutative then {} 
                 else (
                    skewvarsR := R.SkewCommutative;
                    flatten for i in skewvarsR list for j from 0 to dl-1 list t_(i,j)
                    );
    T := kk[t_(0,0)..t_(n-1,dl-1), SkewCommutative=>skewvarsT];
      
   --now find the ideal Td in T of elements of degree >= d.
    Td := product(dl,j->(ideal(apply(n,i->t_(i,j))))^(d_j));
   --define a map R->T
    e:=0;
    targ := apply(numgens R, i -> (
	e = degree R_i;
	product(dl,j->t_(i,j)^(e_j))
	    ));
    phi1 := map(T,R,targ);
       --the desired ideal is a kernel of the composite map R --> T/Td.
    U := T ** R;
    Utarg := ideal apply(numgens R, i -> (
	e = degree R_i;
	sub(R_i,U) - sub(product(dl,j->t_(i,j)^(e_j)),U)
        ));
    J := Utarg + sub(Td, U);
    return trim ideal sub(selectInSubring(1, gens gb J), R);
    psi := map(T/Td,T)*phi1;
    psi
    --ker psi
    )

TEST ///
  S = ZZ/101[a,b, Degrees =>{{0,1},{1,0}}]
  M = S^{-{5,2}, -{2,3}}
  D = {4,3}
  E = {{4,3},{3,4}}
  assert(trunc(D,S) == ideal(a^3*b^4))
  assert(trunc(D,S^1) == image matrix {{a^3*b^4}})
  assert(trunc(E,S^1) == image matrix {{a^3*b^4, a^4*b^3}})
  assert(trunc(E,M) == image(map(S^{{-5, -2}, {-2, -3}},, {{0, 0, a}, {b^2, a*b, 0}})))
-*
  trunc0(D,S^1)
  trunc0(D,M)
  trunc(D,M)
  trunc0(E,M)
*-
///

checkOrMakeDegreeList = method()
checkOrMakeDegreeList(ZZ, ZZ) := (d,degrank) -> (
    if degrank =!= 1 then
        error("expected degree to be of length "|degrank) ;
    {{d}}
    )
checkOrMakeDegreeList(List, ZZ) := (L, degrank) -> (
    if #L === 0 then error "expected non empty list of degrees";
    if all(L, d -> instance(d, ZZ)) then (
        if #L =!= degrank then error("expected a degree of length "|degrank);
        {L}
        )
    else (
        -- all elements of L should be a list of list of integers,
        -- all the same length, and L will be returned.
        if any(L, deg -> not instance(deg, BasicList) 
                         or not all(deg, d -> instance(d,ZZ)) 
                         or #deg =!= degrank)
          then error("expected a list of lists of integers, each of length "|degrank);
        L
        )
    )

canUseTruncation = method()
canUseTruncation Ring := Boolean => R -> (
    A := ultimate(ambient,R);
    isAffineRing A 
    or
    isPolynomialRing A and isAffineRing coefficientRing A and A.?SkewCommutative
    or
    isPolynomialRing A and ZZ === coefficientRing A
    or
    ZZ === A
    )

TEST ///
-*
  restart
*-
  debug needsPackage "Truncations"
  assert(checkOrMakeDegreeList(3, 1) == {{3}})
  assert(checkOrMakeDegreeList({3}, 1) == {{3}})
  assert try checkOrMakeDegreeList(3, 2) else true 
  assert(checkOrMakeDegreeList({1,2}, 2) === {{1,2}})
  assert try checkOrMakeDegreeList({1,2,3}, 2) else true
  assert(checkOrMakeDegreeList({{1,0},{3,-5}}, 2) === {{1,0},{3,-5}})
  assert try checkOrMakeDegreeList({{1,0},{3,-5},{3,4,5}}, 2) else true
  assert try checkOrMakeDegreeList({{1,0},{3,-5},3}, 2) else true
///

truncationMonomials = method()
truncationMonomials(List, Ring) := (d, R) -> (
    -- expected: R is a polynomial ring.
    if not all(d, d1 -> instance(d1,ZZ)) then
        error "expected degree to be a list of integers";
    if #d =!= degreeLength R then 
        error ("expected degree to be of length"|degreeLength R);
    if not R#?(symbol truncation, d) then R#(symbol truncation, d) = (
      -- TODO: check that d is a degree for the ring R
      A := transpose matrix degrees R;
      P := truncationPolyhedron(A,transpose matrix{d});
      C := cone P;
      H := hilbertBasis C;
      H = for h in H list flatten entries h;
      conegens := rsort for h in H list if h#0 === 0 then R_(drop(h,1)) else continue;
      print matrix {conegens};
      gens := for h in H list if h#0 === 1 then R_(drop(h,1)) else continue;
      gens
      );
    R#(symbol truncation, d)
    )

truncationMonomials(List, Ring) := (degs, R) -> (
    degs = checkOrMakeDegreeList(degs, degreeLength R);
    -- expected: R is a polynomial ring.
    if #degs > 1 then
        return sum for d in degs list truncationMonomials(d, R);
    d := degs#0;
    if not R#?(symbol truncation, d) then R#(symbol truncation, d) = (
      -- TODO: check that d is a degree for the ring R
      A := transpose matrix degrees R;
      P := truncationPolyhedron(A,transpose matrix{d});
      C := cone P;
      H := hilbertBasis C;
      H = for h in H list flatten entries h;
      conegens := rsort for h in H list if h#0 === 0 then R_(drop(h,1)) else continue;
      print matrix {conegens};
      gens := for h in H list if h#0 === 1 then R_(drop(h,1)) else continue;
      monomialIdeal gens
      );
    R#(symbol truncation, d)
    )

TEST ///
-* 
  restart
*-
  debug needsPackage "Truncations"
  S = ZZ/101[a,b,c, Degrees =>{5,6,7}]
  truncationMonomials({10}, S)
  truncationMonomials({{9},{11}}, S)
  
  -- TODO MES: add more tests in for this.
  -- In particular, check:
  --   exterior algebra
  --   quotient rings (reduce monomial ideal by the lead terms)?
///

-- truncate the graded ring A in degrees >= d, for d in degs
truncation(List, Ring) := Module => (degs, R) -> (
    if not canUseTruncation R then error "cannot use truncation with this ring type";
    degs = checkOrMakeDegreeList(degs, degreeLength R);
    image gens truncationMonomials(degs,R)
    )

truncation(List, Module) := Module => (degs, M) -> (
    R := ring M;
    if not canUseTruncation R then error "cannot use truncation with this ring type";
    degs = checkOrMakeDegreeList(degs, degreeLength R);
    if isFreeModule M then (
        image map(M,,directSum for a in degrees M list 
            gens truncationMonomials(for d in degs list(d-a),R))
        )
    else (
        -- TODO MES: this isn't correct: use subquotient handling.
        f := presentation M;
        map(M,,truncation(degs, f))
        )
    )

truncation(List, Matrix) := Matrix => (degs, phi) -> (
    -- this is the case when source and target of phi are free modules...
    R := ring phi;
    if not canUseTruncation R then error "cannot use truncation with this ring type";
    degs = checkOrMakeDegreeList(degs, degreeLength R);
    F := truncation(degs, source phi);
    G := truncation(degs, target phi);
    f := gens F;
    g := gens G;
    (phi * f) // g
    )

truncation(List, Ideal) := (degs, I) -> error "not yet implemented"

truncation(ZZ, Ring) :=
truncation(ZZ, Module) :=
truncation(ZZ, Ideal) :=
  (d, R) -> truncation({d}, R)

TEST ///
-*
  restart
  needsPackage "Truncations" 
*-
  S = ZZ/101[a,b, Degrees =>{{0,1},{1,0}}]
  M = S^{-{5,2}, -{2,3}}
  D = {4,3}
  assert(truncation(D,S) == image matrix{{a^3*b^4}})

  E = {{4,3},{3,4}}
  assert(truncation(E,S) == image matrix{{a^3*b^4, a^4*b^3}})

-*
  trunc0(D,S^1)
  trunc0(D,M)
  trunc(D,M)
  trunc0(E,M)
*-
///

TEST ///
-*
  restart
  debug needsPackage "Truncations" 
*-
  S = ZZ/101[a,b,c,d,e,Degrees=>{3,4,5,6,7}]
  sort gens truncation({8},S) == sort gens trunc({8},S^1)
  truncation({8},S^{-4})
  truncation({8},S^{3})
  truncation({8},S^{-4,-5,-3})
  truncation(8,S^{-4,-5,-3})
  phi = random(S^{-1,-2,-3}, S^{-1,-2,-3,-4,-8})
  psi = truncation({8}, phi)
  assert(isHomogeneous psi)
  -- How best to test this??
///


TEST ///
-*
  restart
*-
  debug needsPackage "Truncations" 
  S = ZZ/101[a,b,c,d,e, Degrees=>{3:{1,0},2:{0,1}}]
  assert(sort gens truncation({1,2},S) == sort gens trunc({1,2},S^1))
  assert(sort gens truncation({1,2},S) == sort gens trunc0({1,2},S^1))
///

TEST ///
-*
  restart
  debug needsPackage "Truncations"
*-
  needsPackage "NormalToricVarieties"
  V = smoothFanoToricVariety(3,5)
  rays V
  max V
  S = ring V
  A = transpose matrix degrees S
  truncation({1,1,1}, S)
  basis({1,1,1},S)
  C = posHull A
C2 = dualCone C
rays C2
///

TEST ///
  -- example 2.  A simple one in one dimension
-* 
  restart  
  needsPackage "Truncations"
*-
  A = matrix {{1,2,3,7,8}}
  b = matrix {{6}}
  P = truncationPolyhedron(A,b)
  -- how to use this?
  
  C = cone P -- this is the cone with P at height 1.
  rays C -- TODO: check this
  facets C -- TODO: check this
  hilbertBasis C
  -- It has two kinds of elements in the Hilbert basis, those at height 
  -- zero, and those at height one in the polyhedron
  R = select(hilbertBasis C, h -> h_(0,0) == 0)
  M = select(hilbertBasis C, h -> h_(0,0) == 1)
  -- Cut off first coordinate
  R = apply(R, r->r^{1..(numRows r-1)})
  M = apply(M, m->m^{1..(numRows m-1)})
  
  Q = basisPolyhedron(A,b)
  isCompact Q -- true
  latticePoints Q
  latticePoints P
  
  PE = truncationPolyhedron(A,b,Exterior=>true)
  cone PE
  hilbertBasis oo
  for h in oo list flatten entries h
  select(oo, h -> h#0 == 1)
  matrix oo
  vertices PE -- I think this works in the exterior case...
///  


TEST ///
  kk = ZZ/101
  R = kk[a,b,c,Degrees =>{2:{3,4},{7,5}}]
  d = {5,6}
  D = {d,reverse d}

  elapsedTime J = trunc(d,R)
  M = R^1
  J = trunc(d,R^1)
  J_*/degree
  K = trunc(D,R^1)
///


beginDocumentation()

doc ///
  Key
    Truncations
  Headline
    "truncations of graded ring, ideals and modules"
  Description
    Text
      This package provides for the truncation of a graded ring, or a graded
      module or ideal over a graded ring.
    
      If $R$ is a graded ring, and $M$ is a graded module, and $D$ is a (finite)
      set of degrees, then the truncation {\tt truncation(D, M)} is
      \[M_{\ge D} = XXX \]
  Caveat
    Not yet reimplemented for all ring cases
  SeeAlso
    truncation
    truncate
    basis
///

doc ///
  Key
    truncation
    (truncation,ZZ,Module)
    (truncation,List,Module)
    (truncation,ZZ,Ideal)
    (truncation,List,Ideal)
  Headline
    truncation of the graded ring, ideal or module at a specified degree or set of degrees
  Usage
    truncation(i,M)
  Inputs
    i:ZZ
      or a single multi-degree or a list of multi-degrees
    M:Module
      or a ring or an ideal
  Outputs
    :Module
      or ideal, the submodule of M consisting of all elements of degree $\ge i$
  Description
    Text
    Example
      R = ZZ/101[a..c];
      truncation(2,R^1)
      truncation(2,R^1 ++ R^{-3})
      truncation(2, ideal(a,b,c^3)/ideal(a^2,b^2,c^4))
      truncation(2,ideal(a,b*c,c^7))
    Text
      The base may be ZZ, or another polynomial ring.  In this case, the generators may not
      be minimal, but they do generate.
    Example
      A = ZZ[x,y,z];
      truncation(2,ideal(3*x,5*y,15))
      trim oo
      truncation(2,comodule ideal(3*x,5*y,15))
    Text
      If  {\tt i} is a multi-degree, then the result is the submodule generated by all elements
      of degree exactly {\tt i}, together with all generators of {\tt M} whose first degree is 
      higher than the first degree of {\tt i}.
      The following includes the generator of degree {8,20}.
    Example
      S = ZZ/101[x,y,z,Degrees=>{{1,3},{1,4},{1,-1}}];
      truncation({7,24}, S^1 ++ S^{{-8,-20}})
    Text
      The coefficient ring may also be a polynomial ring.  In this example, the coefficient variables
      also have degree one.  The given generators will generate the truncation over the coefficient ring.
    Example
      B = R[x,y,z, Join=>false]
      degree x
      degree B_3
      truncation(2, B^1)
      truncation(4, ideal(b^2*y,x^3))
    Text
      If the coefficient variables have degree 0:
    Example
      A1 = ZZ/101[a,b,c,Degrees=>{3:{}}]
      degree a
      B1 = A1[x,y]
      truncation(2,B1^1)
      truncation(2, ideal(a^3*x, b*y^2))
  Caveat
  SeeAlso
    basis
    comodule
///

TEST ///
A = ZZ/101[a..d, Degrees => {1,2,3,4}]
assert(truncation(2, A^1) == image matrix {{a^2, a*b, a*c, a*d, b, c, d}})
assert(truncation(4, ideal"a3,b3") == ideal(a^4,a^3*b,a^3*c,a^3*d,b^3))
///

TEST ///
A = ZZ/101[a..d, Degrees => {4:0}]
assert(truncation(2, A^1) == image matrix{{1_A}})
///

TEST ///
A = ZZ/101[a..d]
truncation(2, ideal"a-1,b3+c")
///

TEST ///
A = ZZ/101[a..d, Degrees=>{2:{1,2},2:{0,1}}]
basis({3}, A^1)


A = ZZ/101[a..d, Degrees=>{2:{2,1},2:{1,0}}]
basis({3}, A^1)


A = ZZ/101[a..d, Degrees=>{2:{2,1,0},2:{1,0,0}}]
basis({3,1}, A^1)
///

TEST ///
R=(ZZ/101)[x_0,x_1,y_0,y_1,y_2,Degrees=>{2:{1,1,0},3:{1,0,1}}];
I=ideal random(R^1,R^{6:{-6,-2,-4},4:{-6,-3,-3}});
J = truncation({4,2,2},I);
assert(J == I)
///

TEST ///
-- Singly generated case
R = QQ[a..d]
I = ideal(b*c-a*d,b^2-a*c,d^10)
assert(truncation(2,I) == I)
assert(truncation(3,I) == intersect((ideal vars R)^3, I))

R = QQ[a..d,Degrees=>{3,4,7,9}]
I = ideal(a^3,b^4,c^6)
assert(truncation(12,I) == ideal(a^4,a^3*b,a^3*c,a^3*d,b^4,c^6))

R = ZZ[a,b,c]
I = ideal(15*a,21*b,19*c)
trim truncation(2,I) == ideal(19*c^2,b*c,a*c,21*b^2,3*a*b,15*a^2)
///

end--
restart
uninstallPackage "Truncations"
restart
loadPackage "Truncations"
restart
installPackage "Truncations"

debug needsPackage "Truncations"
-- XXX


-- how to create Ax >= b, x >= 0?
-----------------------------------------------------------------------
---- notes taken by MS and DE in October 2018 for to do for this package
-----------------------------------------------------------------------
restart
load "trunc.m2"
R = ZZ/101[a..d, Degrees=>{3,5,7,9}]
trunc({15}, R)

E = ZZ/101[e_0..e_10, SkewCommutative => true]
trunc0({10}, E^1)
trunc0({11}, E^1)
trunc({3}, E)

gens gb oo

U = E ** T

-------
in trunc(List,Module):
  make the ring U directly, not T.
  instead of phi1, make the ideal we had in trunc(List,Ring).
  
1. change all multi-degrees to be positive. (utility routine)
2. handle quotient rings and modules over them
3. handle exterior algebra
4. trunc creates a ring, which should perhaps be skew commutative.
6. incorporate trunc-new into this package Truncation.

What we really want, is generators for the semigroup
{x in ZZ^n(>=0), Ax >= b}

-- mike doodling about fixing basis command in engine:
Matrix::basis
  KBasis::k_basis(7 arguments)

  
How best to find
  {x in ZZ^n(>=0), Ax = b}
  
  x in ZZ^n
  A is d x n.
  b is in ZZ^d.
  
  Find lattice points in Ax=b, x >= 0.
  
  if possible, Let A1 = Q^-1 * A * P (or A_perm) = (I | C), C is d x (n-d).
  then create a polytope in (n-d) space, then extend each monomial to ZZ^n.
  
-- given a matrix A, d x n whose columns are the degrees of the variables (in ZZ^d),
-- find, if possible a minor with det +-1.  If none, how to handle this?


-- notes 10 Nov 2018, DE, MS
want to solve systems of linear equalities and inequalities in ZZ^n

specifically:
  A be the degree matrix (d x n, n = #vars)
  
  truncate(R, D), D in ZZ^d.
  solve Ax >= D, (might include x >= 0)

  truncate(M, D), M = module.
    take each generator degree E, take Ax >= D-E, then mult each gen
    in degree E by these monomials.


-------------------------------------
-- From an email of Lars Kastner, 10 Nov 2018, in response to a question
-- I (MES) asked him: How to compute generators for the semigroup
--  Ax >= b, x >= 0.
-- Also, find all of the lattice points of Ax=b, x >= 0.
  
Take A={{1,1}} and b={{1/2}}. This gives in your description the two-
dimensional positive orthant without some part of its apex. So the
origin is missing from the lattice points. Then in M2 you can:

loadPackage "Polyhedra"
A = matrix {{1,1}}
b = matrix {{1/2}}
-- The second kind of inequalities, i.e. x>=0
I = matrix map(QQ^2,QQ^2,1)
z = matrix map(QQ^2, QQ^1, 0)
-- Polyhedra uses outer normals for polyhedra, so we have to change the
-- sign. This creates Ax>=b, x>=0/
P = polyhedronFromHData (-(A||I), -(b||z))
-- Consider the cone with the polyhedron at height one
C = cone P
facets C
hilbertBasis C
-- It has two kinds of elements in the Hilbert basis, those at height 
-- zero, and those at height one in the polyhedron
R = select(hilbertBasis C, h -> h_(0,0) == 0)
M = select(hilbertBasis C, h -> h_(0,0) == 1)
-- Cut off first coordinate
R = apply(R, r->r^{1..(numRows r-1)})
M = apply(M, m->m^{1..(numRows m-1)})

Now any lattice point of P is a sum of exactly one element of M and an
arbitrary positive linear combination of elements of R.

Explanation:
C contains all points (h, x) such that -hb+Ax>=0 and -hz+Ix>=0 (+
h>=0). The lattice points you want are those with h=1. You get those by
taking one element of the Hilbert basis with h=1, and adding
arbitrarily many Hilbert basis elements with h=0.


2. Another example:
Pick A={{1,1}} and b={{1}} (almost as above).

Package "Polyhedra"
A = matrix {{1,1}}
b = matrix {{1}}
I = matrix map(QQ^2,QQ^2,1)
z = matrix map(QQ^2, QQ^1, 0)
-- Create polyhedron x>=0, Ax=b
-- This time, A and b describe equations:
P = polyhedronFromHData (-I, -z, A, b)
latticePoints P

Caveat: Ax=b, x>=0 might have infinite solutions anyway. You can check
with 'isCompact P'. Last example:

loadPackage "Polyhedra"
A = matrix {{1,0}}
b = matrix {{1}}
I = matrix map(QQ^2,QQ^2,1)
z = matrix map(QQ^2, QQ^1, 0)
-- Create polyhedron x>=0, Ax=b
P = polyhedronFromHData (-I, -z, A, b)
-- This time, P is not compact
isCompact P
C = cone P
-- inequalities of points in C (note that cones use inner normals)
facets C
-- equations of points in C
hyperplanes C
M = select(hilbertBasis C, h -> h_(0,0) == 1)
M = apply(M, m->m^{1..(numRows m-1)})
R = select(hilbertBasis C, h -> h_(0,0) == 0)
R = apply(R, r->r^{1..(numRows r-1)})

Now every lattice point of P is the sum of exactly one element of M and
an arbitrary positive integral sum of elements of R.

Explanation:
In this case, C contains all points (h, x) such that hb-Ax=0 and
-hz+Ix>=0 (+ h>=0). Then the argument should be as above.


------------------
-- MES examples --
------------------
restart  
needsPackage "Truncations"
-- test of normaliz, to see if it does what we need here:
needsPackage "NormalToricVarieties"

TEST ///
  -- example 1.  A simple one, from Lars' email.
-* 
  restart  
  needsPackage "Truncations"
*-
  A = matrix {{1,1}}
  b = matrix {{1/2}}
  P = truncationPolyhedron(A,b)
  -- how to use this?
  
  C = cone P -- this is the cone with P at height 1.
  rays C -- TODO: check this
  facets C -- TODO: check this
  hilbertBasis C
  -- It has two kinds of elements in the Hilbert basis, those at height 
  -- zero, and those at height one in the polyhedron
  R = select(hilbertBasis C, h -> h_(0,0) == 0)
  M = select(hilbertBasis C, h -> h_(0,0) == 1)
  -- Cut off first coordinate
  R = apply(R, r->r^{1..(numRows r-1)})
  M = apply(M, m->m^{1..(numRows m-1)})
///  


V = smoothFanoToricVariety(3,5)
rays V
max V
S = ring V
A = transpose matrix degrees S
C = posHull A
C2 = dualCone C
rays C2

-- Consider degree (3,2,1)
b = transpose matrix{{3,2,1}}
-(A || id_(QQ^6)), - (b || map(QQ^6, QQ^1, 0))
P = polyhedronFromHData (-(A || id_(QQ^6)), - (b || map(QQ^6, QQ^1, 0)))
vertices P
isCompact P
C = cone P
rays C
facets C
hilbertBasis C
-- It has two kinds of elements in the Hilbert basis, those at height 
-- zero, and those at height one in the polyhedron
R = select(hilbertBasis C, h -> h_(0,0) == 0)
M = select(hilbertBasis C, h -> h_(0,0) == 1)
-- Cut off first coordinate
R = apply(R, r->r^{1..(numRows r-1)})
M = apply(M, m->m^{1..(numRows m-1)})

-- now try Ax = b, x >= 0
I = id_(QQ^6)
z = map(QQ^6, QQ^1, 0)
P = polyhedronFromHData (-I, -z, A, b)
latticePoints P
isCompact P
S = ZZ/101[a..f, Degrees=>entries transpose A]
basis({3,2,1},S)
P = polyhedronFromHData(-id_(QQ^6), -map(QQ^6, QQ^1, 0), A, transpose matrix {{20,5,10}});
LP = elapsedTime latticePoints P; -- slower than one below:
elapsedTime basis({20,5,10}, S);


doc ///
Key
Headline
Usage
Inputs
Outputs
Consequences
Description
  Text
  Example
  Code
  Pre
Caveat
SeeAlso
///

TEST ///
-- test code and assertions here
-- may have as many TEST sections as needed
///
