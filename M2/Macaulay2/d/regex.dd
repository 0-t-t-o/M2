use arithmetic;
use common;
use util;

import search  (pattern:string, start:int, range:int,                      text:string, flags:long):array(int);
import select  (pattern:string, start:int, range:int, replacement: string, text:string, flags:long):array(string);
import replace (pattern:string, start:int, range:int, replacement: string, text:string, flags:long):string;
import separate(pattern:string, start:int, range:int,                      text:string, flags:long):array(string);

toPairs(r:array(int)):Expr := Expr(
    list (
	new Sequence len length(r)/2 at i do
	provide new Sequence len 2 at j do
	provide toExpr(r.(2*i+j))));

regexSearch(e:Expr):Expr := (
    when e is s:Sequence do
    if length(s) == 2 then (
	when s.0 is regexp:stringCell do
	when s.1 is text:stringCell do (
            r := search(regexp.v, 0, length(text.v), text.v, long(-1));
            if length(r) != 0 then toPairs(r)
            else nullE)
        else WrongArgString(2)
	else WrongArgString(1))
    else if length(s) == 5 then (
	when s.0 is regexp:stringCell do
	when s.1 is start:ZZcell do if !isInt(start) then WrongArgSmallInteger(2) else
	when s.2 is range:ZZcell do if !isInt(range) then WrongArgSmallInteger(3) else
	when s.3 is text:stringCell do
	when s.4 is flags:ZZcell do (
	    istart := toInt(start);
	    irange := toInt(range);
            r := search(regexp.v, istart, irange, text.v, toLong(flags));
            if length(r) != 0 then toPairs(r)
            else nullE)
	else WrongArgZZ(5)
	else WrongArgString(4)
	else WrongArgZZ(3)
	else WrongArgZZ(2)
	else WrongArgString(1))
    else WrongNumArgs(5)
    else WrongNumArgs(5));
setupfun("regex", regexSearch).Protected = false; -- will be overloaded in m2/regex.m2

regexReplace(e:Expr):Expr := (
    when e is s:Sequence do
    if length(s) == 3 then (
	when s.0 is regexp:stringCell do
	when s.1 is replacement:stringCell do
	when s.2 is text:stringCell do (
	    toExpr(replace(regexp.v, 0, length(text.v), replacement.v, text.v, long(-1))))
	else WrongArgString(3)
	else WrongArgString(2)
	else WrongArgString(1))
    else if length(s) == 4 then (
	when s.0 is regexp:stringCell do
	when s.1 is replacement:stringCell do
	when s.2 is text:stringCell do
	when s.3 is flags:ZZcell do (
	    toExpr(replace(regexp.v, 0, length(text.v), replacement.v, text.v, toLong(flags))))
	else WrongArgZZ(4)
	else WrongArgString(3)
	else WrongArgString(2)
	else WrongArgString(1))
    else WrongNumArgs(3,4)
    else WrongNumArgs(3,4));
setupfun("replace", regexReplace).Protected = false; -- will be overloaded in m2/regex.m2

regexSeparate(e:Expr):Expr := (
    when e is text:stringCell do (
	toExpr(separate("\r?\n", 0, length(text.v), text.v, long(-1))))
    else when e is s:Sequence do (
    if length(s) == 2 then (
	when s.0 is regexp:stringCell do
	when s.1 is text:stringCell do (
	    toExpr(separate(regexp.v, 0, length(text.v), text.v, long(-1))))
	else WrongArgString(2)
	else WrongArgString(1))
    else if length(s) == 3 then (
	when s.0 is regexp:stringCell do
	when s.1 is text:stringCell do
	when s.2 is flags:ZZcell do (
	    toExpr(separate(regexp.v, 0, length(text.v), text.v, toLong(flags))))
	else WrongArgZZ(3)
	else WrongArgString(2)
	else WrongArgString(1))
    else WrongNumArgs(1,3))
    else WrongNumArgs(1,3));
setupfun("separate", regexSeparate).Protected = false; -- will be overloaded in m2/regex.m2

-- used in actors4.d
export regexSelect(regexp:string, form:string, text:string, flags:long):Expr := (
    toExpr(select(regexp, 0, length(text), form, text, flags)));
