use arithmetic;
use common;
use util;

import search  (pattern:string, start:int, range:int,                      text:string, flags:long):array(int);
import select  (pattern:string, start:int, range:int, replacement: string, text:string, flags:long):array(string);
import replace (pattern:string, start:int, range:int, replacement: string, text:string, flags:long):string;
import separate(pattern:string, start:int, range:int,                      text:string, flags:long):array(string);

toPairs(r:array(int)):Expr := Expr(
    list (
	new Sequence len length(r)/2 at i do
	provide new Sequence len 2 at j do
	provide toExpr(r.(2*i+j))));

regexSearch(e:Expr):Expr := (
    when e is s:Sequence do
    if length(s) == 2 then (
	when s.0 is regexp:stringCell do
	when s.1 is text:stringCell do (
	    Ccode(returns, "try {");
	    r := search(regexp.v, 0, length(text.v), text.v, long(-1));
	    Ccode(returns, "
		} catch (std::exception& e) {
		    fprintf(stderr, \"--internal error: runtime error in compiling regular expression: %s\", e.what());
		    return parse_nullE;
		} catch (...) { return parse_nullE; }");
	    if length(r) != 0 then toPairs(r)
	    else nullE)
	else WrongArgString(2)
	else WrongArgString(1))
    else if length(s) == 5 then (
	when s.0 is regexp:stringCell do
	when s.1 is start:ZZcell do if !isInt(start) then WrongArgSmallInteger(2) else
	when s.2 is range:ZZcell do if !isInt(range) then WrongArgSmallInteger(3) else
	when s.3 is text:stringCell do
	when s.4 is flags:ZZcell do (
	    istart := toInt(start);
	    irange := toInt(range);
	    Ccode(returns, "try {");
	    r := search(regexp.v, istart, irange, text.v, toLong(flags));
	    Ccode(returns, "
		} catch (std::exception& e) {
		    fprintf(stderr, \"--internal error: runtime error in compiling regular expression: %s\", e.what());
		    return parse_nullE;
		} catch (...) { return parse_nullE; }");
	    if length(r) != 0 then toPairs(r)
	    else nullE)
	else WrongArgZZ(5)
	else WrongArgString(4)
	else WrongArgZZ(3)
	else WrongArgZZ(2)
	else WrongArgString(1))
    else WrongNumArgs(5)
    else WrongNumArgs(5));
setupfun("regex", regexSearch).Protected = false; -- will be overloaded in m2/regex.m2

regexReplace(e:Expr):Expr := (
    when e is s:Sequence do
    if length(s) == 3 then (
	when s.0 is regexp:stringCell do
	when s.1 is replacement:stringCell do
	when s.2 is text:stringCell do (
	    Ccode(returns, "try {");
	    r := replace(regexp.v, 0, length(text.v), replacement.v, text.v, long(-1));
	    Ccode(returns, "
		} catch (std::exception& e) {
		    fprintf(stderr, \"--internal error: runtime error in compiling regular expression: %s\", e.what());
		    return parse_nullE;
		} catch (...) { return parse_nullE; }");
	    toExpr(r))
	else WrongArgString(3)
	else WrongArgString(2)
	else WrongArgString(1))
    else if length(s) == 4 then (
	when s.0 is regexp:stringCell do
	when s.1 is replacement:stringCell do
	when s.2 is text:stringCell do
	when s.3 is flags:ZZcell do (
	    Ccode(returns, "try {");
	    r := replace(regexp.v, 0, length(text.v), replacement.v, text.v, toLong(flags));
	    Ccode(returns, "
		} catch (std::exception& e) {
		    fprintf(stderr, \"--internal error: runtime error in compiling regular expression: %s\", e.what());
		    return parse_nullE;
		} catch (...) { return parse_nullE; }");
	    toExpr(r))
	else WrongArgZZ(4)
	else WrongArgString(3)
	else WrongArgString(2)
	else WrongArgString(1))
    else WrongNumArgs(3,4)
    else WrongNumArgs(3,4));
setupfun("replace", regexReplace).Protected = false; -- will be overloaded in m2/regex.m2

regexSeparate(e:Expr):Expr := (
    when e is text:stringCell do (
	Ccode(returns, "try {");
	r := separate("\r?\n", 0, length(text.v), text.v, long(-1));
	Ccode(returns, "
	    } catch (std::exception& e) {
		fprintf(stderr, \"--internal error: runtime error in compiling regular expression: %s\", e.what());
		return parse_nullE;
	    } catch (...) { return parse_nullE; }");
	toExpr(r))
    else when e is s:Sequence do (
    if length(s) == 2 then (
	when s.0 is regexp:stringCell do
	when s.1 is text:stringCell do (
	    Ccode(returns, "try {");
	    r := separate(regexp.v, 0, length(text.v), text.v, long(-1));
	    Ccode(returns, "
		} catch (std::exception& e) {
		    fprintf(stderr, \"--internal error: runtime error in compiling regular expression: %s\", e.what());
		    return parse_nullE;
		} catch (...) { return parse_nullE; }");
	    toExpr(r))
	else WrongArgString(2)
	else WrongArgString(1))
    else if length(s) == 3 then (
	when s.0 is regexp:stringCell do
	when s.1 is text:stringCell do
	when s.2 is flags:ZZcell do (
	    Ccode(returns, "try {");
	    r := separate(regexp.v, 0, length(text.v), text.v, toLong(flags));
	    Ccode(returns, "
		} catch (std::exception& e) {
		    fprintf(stderr, \"--internal error: runtime error in compiling regular expression: %s\", e.what());
		    return parse_nullE;
		} catch (...) { return parse_nullE; }");
	    toExpr(r))
	else WrongArgZZ(3)
	else WrongArgString(2)
	else WrongArgString(1))
    else WrongNumArgs(1,3))
    else WrongNumArgs(1,3));
setupfun("separate", regexSeparate).Protected = false; -- will be overloaded in m2/regex.m2

-- used in actors4.d
export regexSelect(regexp:string, form:string, text:string, flags:long):Expr := (
    Ccode(returns, "try {");
    r := select(regexp, 0, length(text), form, text, flags);
    Ccode(returns, "
	} catch (std::exception& e) {
	    fprintf(stderr, \"--internal error: runtime error in compiling regular expression: %s\", e.what());
	    return parse_nullE;
	} catch (...) { return parse_nullE; }");
    toExpr(r));
